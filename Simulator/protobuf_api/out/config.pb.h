// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_config_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_config_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_config_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_config_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_config_2eproto;
class ConfigGateway;
class ConfigGatewayDefaultTypeInternal;
extern ConfigGatewayDefaultTypeInternal _ConfigGateway_default_instance_;
class ConfigGatewayResponse;
class ConfigGatewayResponseDefaultTypeInternal;
extern ConfigGatewayResponseDefaultTypeInternal _ConfigGatewayResponse_default_instance_;
class Device;
class DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class Dnp3Parms;
class Dnp3ParmsDefaultTypeInternal;
extern Dnp3ParmsDefaultTypeInternal _Dnp3Parms_default_instance_;
class EquipClass;
class EquipClassDefaultTypeInternal;
extern EquipClassDefaultTypeInternal _EquipClass_default_instance_;
class ModbusParms;
class ModbusParmsDefaultTypeInternal;
extern ModbusParmsDefaultTypeInternal _ModbusParms_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ConfigGateway* Arena::CreateMaybeMessage<::ConfigGateway>(Arena*);
template<> ::ConfigGatewayResponse* Arena::CreateMaybeMessage<::ConfigGatewayResponse>(Arena*);
template<> ::Device* Arena::CreateMaybeMessage<::Device>(Arena*);
template<> ::Dnp3Parms* Arena::CreateMaybeMessage<::Dnp3Parms>(Arena*);
template<> ::EquipClass* Arena::CreateMaybeMessage<::EquipClass>(Arena*);
template<> ::ModbusParms* Arena::CreateMaybeMessage<::ModbusParms>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum TDnp3ObjectType_ : int {
  OBJ_BINARY_ = 1,
  OBJ_COUNTER_ = 2,
  OBJ_ANALOG_ = 3,
  OBJ_COMMAND_ = 4,
  OBJ_REGULATION_ = 5,
  OBJ_NONE_ = 6
};
bool TDnp3ObjectType__IsValid(int value);
constexpr TDnp3ObjectType_ TDnp3ObjectType__MIN = OBJ_BINARY_;
constexpr TDnp3ObjectType_ TDnp3ObjectType__MAX = OBJ_NONE_;
constexpr int TDnp3ObjectType__ARRAYSIZE = TDnp3ObjectType__MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TDnp3ObjectType__descriptor();
template<typename T>
inline const std::string& TDnp3ObjectType__Name(T enum_t_value) {
  static_assert(::std::is_same<T, TDnp3ObjectType_>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TDnp3ObjectType__Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TDnp3ObjectType__descriptor(), enum_t_value);
}
inline bool TDnp3ObjectType__Parse(
    const std::string& name, TDnp3ObjectType_* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TDnp3ObjectType_>(
    TDnp3ObjectType__descriptor(), name, value);
}
enum TModbusTypeConn_ : int {
  TCP_ = 1,
  RTU_ = 2,
  RTU_TCP_ = 3
};
bool TModbusTypeConn__IsValid(int value);
constexpr TModbusTypeConn_ TModbusTypeConn__MIN = TCP_;
constexpr TModbusTypeConn_ TModbusTypeConn__MAX = RTU_TCP_;
constexpr int TModbusTypeConn__ARRAYSIZE = TModbusTypeConn__MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TModbusTypeConn__descriptor();
template<typename T>
inline const std::string& TModbusTypeConn__Name(T enum_t_value) {
  static_assert(::std::is_same<T, TModbusTypeConn_>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TModbusTypeConn__Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TModbusTypeConn__descriptor(), enum_t_value);
}
inline bool TModbusTypeConn__Parse(
    const std::string& name, TModbusTypeConn_* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TModbusTypeConn_>(
    TModbusTypeConn__descriptor(), name, value);
}
// ===================================================================

class Dnp3Parms :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Dnp3Parms) */ {
 public:
  Dnp3Parms();
  virtual ~Dnp3Parms();

  Dnp3Parms(const Dnp3Parms& from);
  Dnp3Parms(Dnp3Parms&& from) noexcept
    : Dnp3Parms() {
    *this = ::std::move(from);
  }

  inline Dnp3Parms& operator=(const Dnp3Parms& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dnp3Parms& operator=(Dnp3Parms&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Dnp3Parms& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dnp3Parms* internal_default_instance() {
    return reinterpret_cast<const Dnp3Parms*>(
               &_Dnp3Parms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Dnp3Parms& a, Dnp3Parms& b) {
    a.Swap(&b);
  }
  inline void Swap(Dnp3Parms* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Dnp3Parms* New() const final {
    return CreateMaybeMessage<Dnp3Parms>(nullptr);
  }

  Dnp3Parms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Dnp3Parms>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Dnp3Parms& from);
  void MergeFrom(const Dnp3Parms& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dnp3Parms* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Dnp3Parms";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_config_2eproto);
    return ::descriptor_table_config_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIp1FieldNumber = 2,
    kIp2FieldNumber = 3,
    kIp3FieldNumber = 4,
    kOutstationIdFieldNumber = 1,
    kPort1FieldNumber = 5,
    kPort2FieldNumber = 6,
    kPort3FieldNumber = 7,
    kUnsConnTokenFieldNumber = 8,
    kUnsAddrFieldNumber = 9,
    kMasterId1FieldNumber = 10,
    kMasterId2FieldNumber = 11,
    kMasterId3FieldNumber = 12,
    kAnalogOutPointOffsetFieldNumber = 13,
    kBinaryInConfirmCmdFieldNumber = 14,
    kFailurePointFieldNumber = 15,
    kDnp3FailurePointValFieldNumber = 16,
    kCheckFailureFieldNumber = 17,
    kDnp3FailurePointTypeFieldNumber = 18,
  };
  // required string ip1 = 2;
  bool has_ip1() const;
  private:
  bool _internal_has_ip1() const;
  public:
  void clear_ip1();
  const std::string& ip1() const;
  void set_ip1(const std::string& value);
  void set_ip1(std::string&& value);
  void set_ip1(const char* value);
  void set_ip1(const char* value, size_t size);
  std::string* mutable_ip1();
  std::string* release_ip1();
  void set_allocated_ip1(std::string* ip1);
  private:
  const std::string& _internal_ip1() const;
  void _internal_set_ip1(const std::string& value);
  std::string* _internal_mutable_ip1();
  public:

  // required string ip2 = 3;
  bool has_ip2() const;
  private:
  bool _internal_has_ip2() const;
  public:
  void clear_ip2();
  const std::string& ip2() const;
  void set_ip2(const std::string& value);
  void set_ip2(std::string&& value);
  void set_ip2(const char* value);
  void set_ip2(const char* value, size_t size);
  std::string* mutable_ip2();
  std::string* release_ip2();
  void set_allocated_ip2(std::string* ip2);
  private:
  const std::string& _internal_ip2() const;
  void _internal_set_ip2(const std::string& value);
  std::string* _internal_mutable_ip2();
  public:

  // required string ip3 = 4;
  bool has_ip3() const;
  private:
  bool _internal_has_ip3() const;
  public:
  void clear_ip3();
  const std::string& ip3() const;
  void set_ip3(const std::string& value);
  void set_ip3(std::string&& value);
  void set_ip3(const char* value);
  void set_ip3(const char* value, size_t size);
  std::string* mutable_ip3();
  std::string* release_ip3();
  void set_allocated_ip3(std::string* ip3);
  private:
  const std::string& _internal_ip3() const;
  void _internal_set_ip3(const std::string& value);
  std::string* _internal_mutable_ip3();
  public:

  // required uint32 outstation_id = 1;
  bool has_outstation_id() const;
  private:
  bool _internal_has_outstation_id() const;
  public:
  void clear_outstation_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 outstation_id() const;
  void set_outstation_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_outstation_id() const;
  void _internal_set_outstation_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 port1 = 5;
  bool has_port1() const;
  private:
  bool _internal_has_port1() const;
  public:
  void clear_port1();
  ::PROTOBUF_NAMESPACE_ID::uint32 port1() const;
  void set_port1(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port1() const;
  void _internal_set_port1(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 port2 = 6;
  bool has_port2() const;
  private:
  bool _internal_has_port2() const;
  public:
  void clear_port2();
  ::PROTOBUF_NAMESPACE_ID::uint32 port2() const;
  void set_port2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port2() const;
  void _internal_set_port2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 port3 = 7;
  bool has_port3() const;
  private:
  bool _internal_has_port3() const;
  public:
  void clear_port3();
  ::PROTOBUF_NAMESPACE_ID::uint32 port3() const;
  void set_port3(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port3() const;
  void _internal_set_port3(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 uns_conn_token = 8;
  bool has_uns_conn_token() const;
  private:
  bool _internal_has_uns_conn_token() const;
  public:
  void clear_uns_conn_token();
  ::PROTOBUF_NAMESPACE_ID::uint32 uns_conn_token() const;
  void set_uns_conn_token(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_uns_conn_token() const;
  void _internal_set_uns_conn_token(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 uns_addr = 9;
  bool has_uns_addr() const;
  private:
  bool _internal_has_uns_addr() const;
  public:
  void clear_uns_addr();
  ::PROTOBUF_NAMESPACE_ID::uint32 uns_addr() const;
  void set_uns_addr(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_uns_addr() const;
  void _internal_set_uns_addr(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 master_id1 = 10;
  bool has_master_id1() const;
  private:
  bool _internal_has_master_id1() const;
  public:
  void clear_master_id1();
  ::PROTOBUF_NAMESPACE_ID::uint32 master_id1() const;
  void set_master_id1(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_master_id1() const;
  void _internal_set_master_id1(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 master_id2 = 11;
  bool has_master_id2() const;
  private:
  bool _internal_has_master_id2() const;
  public:
  void clear_master_id2();
  ::PROTOBUF_NAMESPACE_ID::uint32 master_id2() const;
  void set_master_id2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_master_id2() const;
  void _internal_set_master_id2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 master_id3 = 12;
  bool has_master_id3() const;
  private:
  bool _internal_has_master_id3() const;
  public:
  void clear_master_id3();
  ::PROTOBUF_NAMESPACE_ID::uint32 master_id3() const;
  void set_master_id3(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_master_id3() const;
  void _internal_set_master_id3(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 analog_out_point_offset = 13;
  bool has_analog_out_point_offset() const;
  private:
  bool _internal_has_analog_out_point_offset() const;
  public:
  void clear_analog_out_point_offset();
  ::PROTOBUF_NAMESPACE_ID::uint32 analog_out_point_offset() const;
  void set_analog_out_point_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_analog_out_point_offset() const;
  void _internal_set_analog_out_point_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 binary_in_confirm_cmd = 14;
  bool has_binary_in_confirm_cmd() const;
  private:
  bool _internal_has_binary_in_confirm_cmd() const;
  public:
  void clear_binary_in_confirm_cmd();
  ::PROTOBUF_NAMESPACE_ID::uint32 binary_in_confirm_cmd() const;
  void set_binary_in_confirm_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_binary_in_confirm_cmd() const;
  void _internal_set_binary_in_confirm_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 failure_point = 15;
  bool has_failure_point() const;
  private:
  bool _internal_has_failure_point() const;
  public:
  void clear_failure_point();
  ::PROTOBUF_NAMESPACE_ID::uint32 failure_point() const;
  void set_failure_point(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_failure_point() const;
  void _internal_set_failure_point(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required int32 dnp3_failure_point_val = 16;
  bool has_dnp3_failure_point_val() const;
  private:
  bool _internal_has_dnp3_failure_point_val() const;
  public:
  void clear_dnp3_failure_point_val();
  ::PROTOBUF_NAMESPACE_ID::int32 dnp3_failure_point_val() const;
  void set_dnp3_failure_point_val(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dnp3_failure_point_val() const;
  void _internal_set_dnp3_failure_point_val(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required bool check_failure = 17;
  bool has_check_failure() const;
  private:
  bool _internal_has_check_failure() const;
  public:
  void clear_check_failure();
  bool check_failure() const;
  void set_check_failure(bool value);
  private:
  bool _internal_check_failure() const;
  void _internal_set_check_failure(bool value);
  public:

  // required .TDnp3ObjectType_ dnp3_failure_point_type = 18;
  bool has_dnp3_failure_point_type() const;
  private:
  bool _internal_has_dnp3_failure_point_type() const;
  public:
  void clear_dnp3_failure_point_type();
  ::TDnp3ObjectType_ dnp3_failure_point_type() const;
  void set_dnp3_failure_point_type(::TDnp3ObjectType_ value);
  private:
  ::TDnp3ObjectType_ _internal_dnp3_failure_point_type() const;
  void _internal_set_dnp3_failure_point_type(::TDnp3ObjectType_ value);
  public:

  // @@protoc_insertion_point(class_scope:Dnp3Parms)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip3_;
  ::PROTOBUF_NAMESPACE_ID::uint32 outstation_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port1_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port2_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port3_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uns_conn_token_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uns_addr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 master_id1_;
  ::PROTOBUF_NAMESPACE_ID::uint32 master_id2_;
  ::PROTOBUF_NAMESPACE_ID::uint32 master_id3_;
  ::PROTOBUF_NAMESPACE_ID::uint32 analog_out_point_offset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 binary_in_confirm_cmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 failure_point_;
  ::PROTOBUF_NAMESPACE_ID::int32 dnp3_failure_point_val_;
  bool check_failure_;
  int dnp3_failure_point_type_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class ModbusParms :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusParms) */ {
 public:
  ModbusParms();
  virtual ~ModbusParms();

  ModbusParms(const ModbusParms& from);
  ModbusParms(ModbusParms&& from) noexcept
    : ModbusParms() {
    *this = ::std::move(from);
  }

  inline ModbusParms& operator=(const ModbusParms& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusParms& operator=(ModbusParms&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModbusParms& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModbusParms* internal_default_instance() {
    return reinterpret_cast<const ModbusParms*>(
               &_ModbusParms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ModbusParms& a, ModbusParms& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusParms* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModbusParms* New() const final {
    return CreateMaybeMessage<ModbusParms>(nullptr);
  }

  ModbusParms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModbusParms>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModbusParms& from);
  void MergeFrom(const ModbusParms& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusParms* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusParms";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_config_2eproto);
    return ::descriptor_table_config_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 2,
    kDeviceFieldNumber = 7,
    kAddressListFieldNumber = 8,
    kTriggerPathFieldNumber = 15,
    kPortFieldNumber = 3,
    kBaudRateFieldNumber = 4,
    kNumDevsFieldNumber = 5,
    kAddrFieldNumber = 6,
    kTimeoutFieldNumber = 9,
    kInterPollingFieldNumber = 10,
    kIntraPollingFieldNumber = 11,
    kRetryTimeoutFieldNumber = 12,
    kRetriesFieldNumber = 13,
    kPollTriggerFieldNumber = 14,
    kModeFieldNumber = 1,
  };
  // required string ip = 2;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // required string device = 7;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const std::string& device() const;
  void set_device(const std::string& value);
  void set_device(std::string&& value);
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  std::string* mutable_device();
  std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // required string address_list = 8;
  bool has_address_list() const;
  private:
  bool _internal_has_address_list() const;
  public:
  void clear_address_list();
  const std::string& address_list() const;
  void set_address_list(const std::string& value);
  void set_address_list(std::string&& value);
  void set_address_list(const char* value);
  void set_address_list(const char* value, size_t size);
  std::string* mutable_address_list();
  std::string* release_address_list();
  void set_allocated_address_list(std::string* address_list);
  private:
  const std::string& _internal_address_list() const;
  void _internal_set_address_list(const std::string& value);
  std::string* _internal_mutable_address_list();
  public:

  // required string trigger_path = 15;
  bool has_trigger_path() const;
  private:
  bool _internal_has_trigger_path() const;
  public:
  void clear_trigger_path();
  const std::string& trigger_path() const;
  void set_trigger_path(const std::string& value);
  void set_trigger_path(std::string&& value);
  void set_trigger_path(const char* value);
  void set_trigger_path(const char* value, size_t size);
  std::string* mutable_trigger_path();
  std::string* release_trigger_path();
  void set_allocated_trigger_path(std::string* trigger_path);
  private:
  const std::string& _internal_trigger_path() const;
  void _internal_set_trigger_path(const std::string& value);
  std::string* _internal_mutable_trigger_path();
  public:

  // required uint32 port = 3;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 baud_rate = 4;
  bool has_baud_rate() const;
  private:
  bool _internal_has_baud_rate() const;
  public:
  void clear_baud_rate();
  ::PROTOBUF_NAMESPACE_ID::uint32 baud_rate() const;
  void set_baud_rate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_baud_rate() const;
  void _internal_set_baud_rate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 num_devs = 5;
  bool has_num_devs() const;
  private:
  bool _internal_has_num_devs() const;
  public:
  void clear_num_devs();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_devs() const;
  void set_num_devs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_devs() const;
  void _internal_set_num_devs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 addr = 6;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  ::PROTOBUF_NAMESPACE_ID::uint32 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_addr() const;
  void _internal_set_addr(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 timeout = 9;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  ::PROTOBUF_NAMESPACE_ID::uint32 timeout() const;
  void set_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timeout() const;
  void _internal_set_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 inter_polling = 10;
  bool has_inter_polling() const;
  private:
  bool _internal_has_inter_polling() const;
  public:
  void clear_inter_polling();
  ::PROTOBUF_NAMESPACE_ID::uint32 inter_polling() const;
  void set_inter_polling(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_inter_polling() const;
  void _internal_set_inter_polling(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 intra_polling = 11;
  bool has_intra_polling() const;
  private:
  bool _internal_has_intra_polling() const;
  public:
  void clear_intra_polling();
  ::PROTOBUF_NAMESPACE_ID::uint32 intra_polling() const;
  void set_intra_polling(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_intra_polling() const;
  void _internal_set_intra_polling(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 retry_timeout = 12;
  bool has_retry_timeout() const;
  private:
  bool _internal_has_retry_timeout() const;
  public:
  void clear_retry_timeout();
  ::PROTOBUF_NAMESPACE_ID::uint32 retry_timeout() const;
  void set_retry_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_retry_timeout() const;
  void _internal_set_retry_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 retries = 13;
  bool has_retries() const;
  private:
  bool _internal_has_retries() const;
  public:
  void clear_retries();
  ::PROTOBUF_NAMESPACE_ID::uint32 retries() const;
  void set_retries(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_retries() const;
  void _internal_set_retries(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 poll_trigger = 14;
  bool has_poll_trigger() const;
  private:
  bool _internal_has_poll_trigger() const;
  public:
  void clear_poll_trigger();
  ::PROTOBUF_NAMESPACE_ID::uint32 poll_trigger() const;
  void set_poll_trigger(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_poll_trigger() const;
  void _internal_set_poll_trigger(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .TModbusTypeConn_ mode = 1;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::TModbusTypeConn_ mode() const;
  void set_mode(::TModbusTypeConn_ value);
  private:
  ::TModbusTypeConn_ _internal_mode() const;
  void _internal_set_mode(::TModbusTypeConn_ value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusParms)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_path_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 baud_rate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_devs_;
  ::PROTOBUF_NAMESPACE_ID::uint32 addr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timeout_;
  ::PROTOBUF_NAMESPACE_ID::uint32 inter_polling_;
  ::PROTOBUF_NAMESPACE_ID::uint32 intra_polling_;
  ::PROTOBUF_NAMESPACE_ID::uint32 retry_timeout_;
  ::PROTOBUF_NAMESPACE_ID::uint32 retries_;
  ::PROTOBUF_NAMESPACE_ID::uint32 poll_trigger_;
  int mode_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class EquipClass :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EquipClass) */ {
 public:
  EquipClass();
  virtual ~EquipClass();

  EquipClass(const EquipClass& from);
  EquipClass(EquipClass&& from) noexcept
    : EquipClass() {
    *this = ::std::move(from);
  }

  inline EquipClass& operator=(const EquipClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipClass& operator=(EquipClass&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EquipClass& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EquipClass* internal_default_instance() {
    return reinterpret_cast<const EquipClass*>(
               &_EquipClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EquipClass& a, EquipClass& b) {
    a.Swap(&b);
  }
  inline void Swap(EquipClass* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EquipClass* New() const final {
    return CreateMaybeMessage<EquipClass>(nullptr);
  }

  EquipClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EquipClass>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EquipClass& from);
  void MergeFrom(const EquipClass& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipClass* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EquipClass";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_config_2eproto);
    return ::descriptor_table_config_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kVersionFieldNumber = 5,
    kClassmapDescriptionFieldNumber = 6,
    kClassmapPathFieldNumber = 7,
    kClassIdFieldNumber = 1,
    kTypeIdFieldNumber = 2,
    kMapIdFieldNumber = 3,
  };
  // required string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string version = 5;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // required string classmap_description = 6;
  bool has_classmap_description() const;
  private:
  bool _internal_has_classmap_description() const;
  public:
  void clear_classmap_description();
  const std::string& classmap_description() const;
  void set_classmap_description(const std::string& value);
  void set_classmap_description(std::string&& value);
  void set_classmap_description(const char* value);
  void set_classmap_description(const char* value, size_t size);
  std::string* mutable_classmap_description();
  std::string* release_classmap_description();
  void set_allocated_classmap_description(std::string* classmap_description);
  private:
  const std::string& _internal_classmap_description() const;
  void _internal_set_classmap_description(const std::string& value);
  std::string* _internal_mutable_classmap_description();
  public:

  // required string classmap_path = 7;
  bool has_classmap_path() const;
  private:
  bool _internal_has_classmap_path() const;
  public:
  void clear_classmap_path();
  const std::string& classmap_path() const;
  void set_classmap_path(const std::string& value);
  void set_classmap_path(std::string&& value);
  void set_classmap_path(const char* value);
  void set_classmap_path(const char* value, size_t size);
  std::string* mutable_classmap_path();
  std::string* release_classmap_path();
  void set_allocated_classmap_path(std::string* classmap_path);
  private:
  const std::string& _internal_classmap_path() const;
  void _internal_set_classmap_path(const std::string& value);
  std::string* _internal_mutable_classmap_path();
  public:

  // required uint32 classId = 1;
  bool has_classid() const;
  private:
  bool _internal_has_classid() const;
  public:
  void clear_classid();
  ::PROTOBUF_NAMESPACE_ID::uint32 classid() const;
  void set_classid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_classid() const;
  void _internal_set_classid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 typeId = 2;
  bool has_typeid_() const;
  private:
  bool _internal_has_typeid_() const;
  public:
  void clear_typeid_();
  ::PROTOBUF_NAMESPACE_ID::uint32 typeid_() const;
  void set_typeid_(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_typeid_() const;
  void _internal_set_typeid_(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 mapId = 3;
  bool has_mapid() const;
  private:
  bool _internal_has_mapid() const;
  public:
  void clear_mapid();
  ::PROTOBUF_NAMESPACE_ID::uint32 mapid() const;
  void set_mapid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mapid() const;
  void _internal_set_mapid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:EquipClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classmap_description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classmap_path_;
  ::PROTOBUF_NAMESPACE_ID::uint32 classid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 typeid__;
  ::PROTOBUF_NAMESPACE_ID::uint32 mapid_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class Device :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Device) */ {
 public:
  Device();
  virtual ~Device();

  Device(const Device& from);
  Device(Device&& from) noexcept
    : Device() {
    *this = ::std::move(from);
  }

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline Device& operator=(Device&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Device& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
               &_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Device& a, Device& b) {
    a.Swap(&b);
  }
  inline void Swap(Device* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Device* New() const final {
    return CreateMaybeMessage<Device>(nullptr);
  }

  Device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Device>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Device* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Device";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_config_2eproto);
    return ::descriptor_table_config_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kManufacturerFieldNumber = 2,
    kModelFieldNumber = 3,
    kModbusCfgFieldNumber = 6,
    kDnp3CfgFieldNumber = 7,
    kClassmapFieldNumber = 8,
    kClassIdFieldNumber = 4,
    kUgFieldNumber = 5,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string manufacturer = 2;
  bool has_manufacturer() const;
  private:
  bool _internal_has_manufacturer() const;
  public:
  void clear_manufacturer();
  const std::string& manufacturer() const;
  void set_manufacturer(const std::string& value);
  void set_manufacturer(std::string&& value);
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  std::string* mutable_manufacturer();
  std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // required string model = 3;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const std::string& model() const;
  void set_model(const std::string& value);
  void set_model(std::string&& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  std::string* mutable_model();
  std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // required .ModbusParms modbus_cfg = 6;
  bool has_modbus_cfg() const;
  private:
  bool _internal_has_modbus_cfg() const;
  public:
  void clear_modbus_cfg();
  const ::ModbusParms& modbus_cfg() const;
  ::ModbusParms* release_modbus_cfg();
  ::ModbusParms* mutable_modbus_cfg();
  void set_allocated_modbus_cfg(::ModbusParms* modbus_cfg);
  private:
  const ::ModbusParms& _internal_modbus_cfg() const;
  ::ModbusParms* _internal_mutable_modbus_cfg();
  public:

  // required .Dnp3Parms dnp3_cfg = 7;
  bool has_dnp3_cfg() const;
  private:
  bool _internal_has_dnp3_cfg() const;
  public:
  void clear_dnp3_cfg();
  const ::Dnp3Parms& dnp3_cfg() const;
  ::Dnp3Parms* release_dnp3_cfg();
  ::Dnp3Parms* mutable_dnp3_cfg();
  void set_allocated_dnp3_cfg(::Dnp3Parms* dnp3_cfg);
  private:
  const ::Dnp3Parms& _internal_dnp3_cfg() const;
  ::Dnp3Parms* _internal_mutable_dnp3_cfg();
  public:

  // required .EquipClass classmap = 8;
  bool has_classmap() const;
  private:
  bool _internal_has_classmap() const;
  public:
  void clear_classmap();
  const ::EquipClass& classmap() const;
  ::EquipClass* release_classmap();
  ::EquipClass* mutable_classmap();
  void set_allocated_classmap(::EquipClass* classmap);
  private:
  const ::EquipClass& _internal_classmap() const;
  ::EquipClass* _internal_mutable_classmap();
  public:

  // required uint32 class_id = 4;
  bool has_class_id() const;
  private:
  bool _internal_has_class_id() const;
  public:
  void clear_class_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 class_id() const;
  void set_class_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_class_id() const;
  void _internal_set_class_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 ug = 5;
  bool has_ug() const;
  private:
  bool _internal_has_ug() const;
  public:
  void clear_ug();
  ::PROTOBUF_NAMESPACE_ID::uint32 ug() const;
  void set_ug(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ug() const;
  void _internal_set_ug(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Device)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::ModbusParms* modbus_cfg_;
  ::Dnp3Parms* dnp3_cfg_;
  ::EquipClass* classmap_;
  ::PROTOBUF_NAMESPACE_ID::uint32 class_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ug_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class ConfigGateway :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConfigGateway) */ {
 public:
  ConfigGateway();
  virtual ~ConfigGateway();

  ConfigGateway(const ConfigGateway& from);
  ConfigGateway(ConfigGateway&& from) noexcept
    : ConfigGateway() {
    *this = ::std::move(from);
  }

  inline ConfigGateway& operator=(const ConfigGateway& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigGateway& operator=(ConfigGateway&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConfigGateway& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigGateway* internal_default_instance() {
    return reinterpret_cast<const ConfigGateway*>(
               &_ConfigGateway_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConfigGateway& a, ConfigGateway& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigGateway* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConfigGateway* New() const final {
    return CreateMaybeMessage<ConfigGateway>(nullptr);
  }

  ConfigGateway* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigGateway>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConfigGateway& from);
  void MergeFrom(const ConfigGateway& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigGateway* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConfigGateway";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_config_2eproto);
    return ::descriptor_table_config_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .Device devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::Device* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Device >*
      mutable_devices();
  private:
  const ::Device& _internal_devices(int index) const;
  ::Device* _internal_add_devices();
  public:
  const ::Device& devices(int index) const;
  ::Device* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Device >&
      devices() const;

  // @@protoc_insertion_point(class_scope:ConfigGateway)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Device > devices_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class ConfigGatewayResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConfigGatewayResponse) */ {
 public:
  ConfigGatewayResponse();
  virtual ~ConfigGatewayResponse();

  ConfigGatewayResponse(const ConfigGatewayResponse& from);
  ConfigGatewayResponse(ConfigGatewayResponse&& from) noexcept
    : ConfigGatewayResponse() {
    *this = ::std::move(from);
  }

  inline ConfigGatewayResponse& operator=(const ConfigGatewayResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigGatewayResponse& operator=(ConfigGatewayResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConfigGatewayResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigGatewayResponse* internal_default_instance() {
    return reinterpret_cast<const ConfigGatewayResponse*>(
               &_ConfigGatewayResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConfigGatewayResponse& a, ConfigGatewayResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigGatewayResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConfigGatewayResponse* New() const final {
    return CreateMaybeMessage<ConfigGatewayResponse>(nullptr);
  }

  ConfigGatewayResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigGatewayResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConfigGatewayResponse& from);
  void MergeFrom(const ConfigGatewayResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigGatewayResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConfigGatewayResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_config_2eproto);
    return ::descriptor_table_config_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrMsgFieldNumber = 3,
    kNumDevicesCfgFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // optional string errMsg = 3;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  void set_errmsg(const std::string& value);
  void set_errmsg(std::string&& value);
  void set_errmsg(const char* value);
  void set_errmsg(const char* value, size_t size);
  std::string* mutable_errmsg();
  std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // required uint32 numDevicesCfg = 1;
  bool has_numdevicescfg() const;
  private:
  bool _internal_has_numdevicescfg() const;
  public:
  void clear_numdevicescfg();
  ::PROTOBUF_NAMESPACE_ID::uint32 numdevicescfg() const;
  void set_numdevicescfg(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_numdevicescfg() const;
  void _internal_set_numdevicescfg(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required bool success = 2;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ConfigGatewayResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::uint32 numdevicescfg_;
  bool success_;
  friend struct ::TableStruct_config_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Dnp3Parms

// required uint32 outstation_id = 1;
inline bool Dnp3Parms::_internal_has_outstation_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Dnp3Parms::has_outstation_id() const {
  return _internal_has_outstation_id();
}
inline void Dnp3Parms::clear_outstation_id() {
  outstation_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_outstation_id() const {
  return outstation_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::outstation_id() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.outstation_id)
  return _internal_outstation_id();
}
inline void Dnp3Parms::_internal_set_outstation_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  outstation_id_ = value;
}
inline void Dnp3Parms::set_outstation_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_outstation_id(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.outstation_id)
}

// required string ip1 = 2;
inline bool Dnp3Parms::_internal_has_ip1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Dnp3Parms::has_ip1() const {
  return _internal_has_ip1();
}
inline void Dnp3Parms::clear_ip1() {
  ip1_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Dnp3Parms::ip1() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.ip1)
  return _internal_ip1();
}
inline void Dnp3Parms::set_ip1(const std::string& value) {
  _internal_set_ip1(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.ip1)
}
inline std::string* Dnp3Parms::mutable_ip1() {
  // @@protoc_insertion_point(field_mutable:Dnp3Parms.ip1)
  return _internal_mutable_ip1();
}
inline const std::string& Dnp3Parms::_internal_ip1() const {
  return ip1_.GetNoArena();
}
inline void Dnp3Parms::_internal_set_ip1(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Dnp3Parms::set_ip1(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ip1_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Dnp3Parms.ip1)
}
inline void Dnp3Parms::set_ip1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ip1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Dnp3Parms.ip1)
}
inline void Dnp3Parms::set_ip1(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ip1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Dnp3Parms.ip1)
}
inline std::string* Dnp3Parms::_internal_mutable_ip1() {
  _has_bits_[0] |= 0x00000001u;
  return ip1_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Dnp3Parms::release_ip1() {
  // @@protoc_insertion_point(field_release:Dnp3Parms.ip1)
  if (!_internal_has_ip1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ip1_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Dnp3Parms::set_allocated_ip1(std::string* ip1) {
  if (ip1 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip1_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip1);
  // @@protoc_insertion_point(field_set_allocated:Dnp3Parms.ip1)
}

// required string ip2 = 3;
inline bool Dnp3Parms::_internal_has_ip2() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Dnp3Parms::has_ip2() const {
  return _internal_has_ip2();
}
inline void Dnp3Parms::clear_ip2() {
  ip2_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Dnp3Parms::ip2() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.ip2)
  return _internal_ip2();
}
inline void Dnp3Parms::set_ip2(const std::string& value) {
  _internal_set_ip2(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.ip2)
}
inline std::string* Dnp3Parms::mutable_ip2() {
  // @@protoc_insertion_point(field_mutable:Dnp3Parms.ip2)
  return _internal_mutable_ip2();
}
inline const std::string& Dnp3Parms::_internal_ip2() const {
  return ip2_.GetNoArena();
}
inline void Dnp3Parms::_internal_set_ip2(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ip2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Dnp3Parms::set_ip2(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ip2_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Dnp3Parms.ip2)
}
inline void Dnp3Parms::set_ip2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ip2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Dnp3Parms.ip2)
}
inline void Dnp3Parms::set_ip2(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ip2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Dnp3Parms.ip2)
}
inline std::string* Dnp3Parms::_internal_mutable_ip2() {
  _has_bits_[0] |= 0x00000002u;
  return ip2_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Dnp3Parms::release_ip2() {
  // @@protoc_insertion_point(field_release:Dnp3Parms.ip2)
  if (!_internal_has_ip2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ip2_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Dnp3Parms::set_allocated_ip2(std::string* ip2) {
  if (ip2 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip2_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip2);
  // @@protoc_insertion_point(field_set_allocated:Dnp3Parms.ip2)
}

// required string ip3 = 4;
inline bool Dnp3Parms::_internal_has_ip3() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Dnp3Parms::has_ip3() const {
  return _internal_has_ip3();
}
inline void Dnp3Parms::clear_ip3() {
  ip3_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Dnp3Parms::ip3() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.ip3)
  return _internal_ip3();
}
inline void Dnp3Parms::set_ip3(const std::string& value) {
  _internal_set_ip3(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.ip3)
}
inline std::string* Dnp3Parms::mutable_ip3() {
  // @@protoc_insertion_point(field_mutable:Dnp3Parms.ip3)
  return _internal_mutable_ip3();
}
inline const std::string& Dnp3Parms::_internal_ip3() const {
  return ip3_.GetNoArena();
}
inline void Dnp3Parms::_internal_set_ip3(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ip3_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Dnp3Parms::set_ip3(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  ip3_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Dnp3Parms.ip3)
}
inline void Dnp3Parms::set_ip3(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  ip3_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Dnp3Parms.ip3)
}
inline void Dnp3Parms::set_ip3(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  ip3_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Dnp3Parms.ip3)
}
inline std::string* Dnp3Parms::_internal_mutable_ip3() {
  _has_bits_[0] |= 0x00000004u;
  return ip3_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Dnp3Parms::release_ip3() {
  // @@protoc_insertion_point(field_release:Dnp3Parms.ip3)
  if (!_internal_has_ip3()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return ip3_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Dnp3Parms::set_allocated_ip3(std::string* ip3) {
  if (ip3 != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ip3_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip3);
  // @@protoc_insertion_point(field_set_allocated:Dnp3Parms.ip3)
}

// required uint32 port1 = 5;
inline bool Dnp3Parms::_internal_has_port1() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Dnp3Parms::has_port1() const {
  return _internal_has_port1();
}
inline void Dnp3Parms::clear_port1() {
  port1_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_port1() const {
  return port1_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::port1() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.port1)
  return _internal_port1();
}
inline void Dnp3Parms::_internal_set_port1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  port1_ = value;
}
inline void Dnp3Parms::set_port1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port1(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.port1)
}

// required uint32 port2 = 6;
inline bool Dnp3Parms::_internal_has_port2() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Dnp3Parms::has_port2() const {
  return _internal_has_port2();
}
inline void Dnp3Parms::clear_port2() {
  port2_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_port2() const {
  return port2_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::port2() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.port2)
  return _internal_port2();
}
inline void Dnp3Parms::_internal_set_port2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  port2_ = value;
}
inline void Dnp3Parms::set_port2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port2(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.port2)
}

// required uint32 port3 = 7;
inline bool Dnp3Parms::_internal_has_port3() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Dnp3Parms::has_port3() const {
  return _internal_has_port3();
}
inline void Dnp3Parms::clear_port3() {
  port3_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_port3() const {
  return port3_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::port3() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.port3)
  return _internal_port3();
}
inline void Dnp3Parms::_internal_set_port3(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  port3_ = value;
}
inline void Dnp3Parms::set_port3(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port3(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.port3)
}

// required uint32 uns_conn_token = 8;
inline bool Dnp3Parms::_internal_has_uns_conn_token() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Dnp3Parms::has_uns_conn_token() const {
  return _internal_has_uns_conn_token();
}
inline void Dnp3Parms::clear_uns_conn_token() {
  uns_conn_token_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_uns_conn_token() const {
  return uns_conn_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::uns_conn_token() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.uns_conn_token)
  return _internal_uns_conn_token();
}
inline void Dnp3Parms::_internal_set_uns_conn_token(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  uns_conn_token_ = value;
}
inline void Dnp3Parms::set_uns_conn_token(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_uns_conn_token(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.uns_conn_token)
}

// required uint32 uns_addr = 9;
inline bool Dnp3Parms::_internal_has_uns_addr() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Dnp3Parms::has_uns_addr() const {
  return _internal_has_uns_addr();
}
inline void Dnp3Parms::clear_uns_addr() {
  uns_addr_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_uns_addr() const {
  return uns_addr_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::uns_addr() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.uns_addr)
  return _internal_uns_addr();
}
inline void Dnp3Parms::_internal_set_uns_addr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  uns_addr_ = value;
}
inline void Dnp3Parms::set_uns_addr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_uns_addr(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.uns_addr)
}

// required uint32 master_id1 = 10;
inline bool Dnp3Parms::_internal_has_master_id1() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Dnp3Parms::has_master_id1() const {
  return _internal_has_master_id1();
}
inline void Dnp3Parms::clear_master_id1() {
  master_id1_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_master_id1() const {
  return master_id1_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::master_id1() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.master_id1)
  return _internal_master_id1();
}
inline void Dnp3Parms::_internal_set_master_id1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  master_id1_ = value;
}
inline void Dnp3Parms::set_master_id1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_master_id1(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.master_id1)
}

// required uint32 master_id2 = 11;
inline bool Dnp3Parms::_internal_has_master_id2() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Dnp3Parms::has_master_id2() const {
  return _internal_has_master_id2();
}
inline void Dnp3Parms::clear_master_id2() {
  master_id2_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_master_id2() const {
  return master_id2_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::master_id2() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.master_id2)
  return _internal_master_id2();
}
inline void Dnp3Parms::_internal_set_master_id2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  master_id2_ = value;
}
inline void Dnp3Parms::set_master_id2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_master_id2(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.master_id2)
}

// required uint32 master_id3 = 12;
inline bool Dnp3Parms::_internal_has_master_id3() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Dnp3Parms::has_master_id3() const {
  return _internal_has_master_id3();
}
inline void Dnp3Parms::clear_master_id3() {
  master_id3_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_master_id3() const {
  return master_id3_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::master_id3() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.master_id3)
  return _internal_master_id3();
}
inline void Dnp3Parms::_internal_set_master_id3(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  master_id3_ = value;
}
inline void Dnp3Parms::set_master_id3(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_master_id3(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.master_id3)
}

// required uint32 analog_out_point_offset = 13;
inline bool Dnp3Parms::_internal_has_analog_out_point_offset() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Dnp3Parms::has_analog_out_point_offset() const {
  return _internal_has_analog_out_point_offset();
}
inline void Dnp3Parms::clear_analog_out_point_offset() {
  analog_out_point_offset_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_analog_out_point_offset() const {
  return analog_out_point_offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::analog_out_point_offset() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.analog_out_point_offset)
  return _internal_analog_out_point_offset();
}
inline void Dnp3Parms::_internal_set_analog_out_point_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  analog_out_point_offset_ = value;
}
inline void Dnp3Parms::set_analog_out_point_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_analog_out_point_offset(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.analog_out_point_offset)
}

// required uint32 binary_in_confirm_cmd = 14;
inline bool Dnp3Parms::_internal_has_binary_in_confirm_cmd() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Dnp3Parms::has_binary_in_confirm_cmd() const {
  return _internal_has_binary_in_confirm_cmd();
}
inline void Dnp3Parms::clear_binary_in_confirm_cmd() {
  binary_in_confirm_cmd_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_binary_in_confirm_cmd() const {
  return binary_in_confirm_cmd_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::binary_in_confirm_cmd() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.binary_in_confirm_cmd)
  return _internal_binary_in_confirm_cmd();
}
inline void Dnp3Parms::_internal_set_binary_in_confirm_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  binary_in_confirm_cmd_ = value;
}
inline void Dnp3Parms::set_binary_in_confirm_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_binary_in_confirm_cmd(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.binary_in_confirm_cmd)
}

// required uint32 failure_point = 15;
inline bool Dnp3Parms::_internal_has_failure_point() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Dnp3Parms::has_failure_point() const {
  return _internal_has_failure_point();
}
inline void Dnp3Parms::clear_failure_point() {
  failure_point_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::_internal_failure_point() const {
  return failure_point_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Dnp3Parms::failure_point() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.failure_point)
  return _internal_failure_point();
}
inline void Dnp3Parms::_internal_set_failure_point(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  failure_point_ = value;
}
inline void Dnp3Parms::set_failure_point(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_failure_point(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.failure_point)
}

// required int32 dnp3_failure_point_val = 16;
inline bool Dnp3Parms::_internal_has_dnp3_failure_point_val() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Dnp3Parms::has_dnp3_failure_point_val() const {
  return _internal_has_dnp3_failure_point_val();
}
inline void Dnp3Parms::clear_dnp3_failure_point_val() {
  dnp3_failure_point_val_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Dnp3Parms::_internal_dnp3_failure_point_val() const {
  return dnp3_failure_point_val_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Dnp3Parms::dnp3_failure_point_val() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.dnp3_failure_point_val)
  return _internal_dnp3_failure_point_val();
}
inline void Dnp3Parms::_internal_set_dnp3_failure_point_val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00008000u;
  dnp3_failure_point_val_ = value;
}
inline void Dnp3Parms::set_dnp3_failure_point_val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dnp3_failure_point_val(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.dnp3_failure_point_val)
}

// required bool check_failure = 17;
inline bool Dnp3Parms::_internal_has_check_failure() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Dnp3Parms::has_check_failure() const {
  return _internal_has_check_failure();
}
inline void Dnp3Parms::clear_check_failure() {
  check_failure_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool Dnp3Parms::_internal_check_failure() const {
  return check_failure_;
}
inline bool Dnp3Parms::check_failure() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.check_failure)
  return _internal_check_failure();
}
inline void Dnp3Parms::_internal_set_check_failure(bool value) {
  _has_bits_[0] |= 0x00010000u;
  check_failure_ = value;
}
inline void Dnp3Parms::set_check_failure(bool value) {
  _internal_set_check_failure(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.check_failure)
}

// required .TDnp3ObjectType_ dnp3_failure_point_type = 18;
inline bool Dnp3Parms::_internal_has_dnp3_failure_point_type() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Dnp3Parms::has_dnp3_failure_point_type() const {
  return _internal_has_dnp3_failure_point_type();
}
inline void Dnp3Parms::clear_dnp3_failure_point_type() {
  dnp3_failure_point_type_ = 1;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::TDnp3ObjectType_ Dnp3Parms::_internal_dnp3_failure_point_type() const {
  return static_cast< ::TDnp3ObjectType_ >(dnp3_failure_point_type_);
}
inline ::TDnp3ObjectType_ Dnp3Parms::dnp3_failure_point_type() const {
  // @@protoc_insertion_point(field_get:Dnp3Parms.dnp3_failure_point_type)
  return _internal_dnp3_failure_point_type();
}
inline void Dnp3Parms::_internal_set_dnp3_failure_point_type(::TDnp3ObjectType_ value) {
  assert(::TDnp3ObjectType__IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  dnp3_failure_point_type_ = value;
}
inline void Dnp3Parms::set_dnp3_failure_point_type(::TDnp3ObjectType_ value) {
  _internal_set_dnp3_failure_point_type(value);
  // @@protoc_insertion_point(field_set:Dnp3Parms.dnp3_failure_point_type)
}

// -------------------------------------------------------------------

// ModbusParms

// required .TModbusTypeConn_ mode = 1;
inline bool ModbusParms::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ModbusParms::has_mode() const {
  return _internal_has_mode();
}
inline void ModbusParms::clear_mode() {
  mode_ = 1;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::TModbusTypeConn_ ModbusParms::_internal_mode() const {
  return static_cast< ::TModbusTypeConn_ >(mode_);
}
inline ::TModbusTypeConn_ ModbusParms::mode() const {
  // @@protoc_insertion_point(field_get:ModbusParms.mode)
  return _internal_mode();
}
inline void ModbusParms::_internal_set_mode(::TModbusTypeConn_ value) {
  assert(::TModbusTypeConn__IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  mode_ = value;
}
inline void ModbusParms::set_mode(::TModbusTypeConn_ value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:ModbusParms.mode)
}

// required string ip = 2;
inline bool ModbusParms::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModbusParms::has_ip() const {
  return _internal_has_ip();
}
inline void ModbusParms::clear_ip() {
  ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModbusParms::ip() const {
  // @@protoc_insertion_point(field_get:ModbusParms.ip)
  return _internal_ip();
}
inline void ModbusParms::set_ip(const std::string& value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:ModbusParms.ip)
}
inline std::string* ModbusParms::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:ModbusParms.ip)
  return _internal_mutable_ip();
}
inline const std::string& ModbusParms::_internal_ip() const {
  return ip_.GetNoArena();
}
inline void ModbusParms::_internal_set_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusParms::set_ip(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusParms.ip)
}
inline void ModbusParms::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusParms.ip)
}
inline void ModbusParms::set_ip(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusParms.ip)
}
inline std::string* ModbusParms::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000001u;
  return ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusParms::release_ip() {
  // @@protoc_insertion_point(field_release:ModbusParms.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ip_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusParms::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:ModbusParms.ip)
}

// required uint32 port = 3;
inline bool ModbusParms::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ModbusParms::has_port() const {
  return _internal_has_port();
}
inline void ModbusParms::clear_port() {
  port_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::port() const {
  // @@protoc_insertion_point(field_get:ModbusParms.port)
  return _internal_port();
}
inline void ModbusParms::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  port_ = value;
}
inline void ModbusParms::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:ModbusParms.port)
}

// required uint32 baud_rate = 4;
inline bool ModbusParms::_internal_has_baud_rate() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ModbusParms::has_baud_rate() const {
  return _internal_has_baud_rate();
}
inline void ModbusParms::clear_baud_rate() {
  baud_rate_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::_internal_baud_rate() const {
  return baud_rate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::baud_rate() const {
  // @@protoc_insertion_point(field_get:ModbusParms.baud_rate)
  return _internal_baud_rate();
}
inline void ModbusParms::_internal_set_baud_rate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  baud_rate_ = value;
}
inline void ModbusParms::set_baud_rate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_baud_rate(value);
  // @@protoc_insertion_point(field_set:ModbusParms.baud_rate)
}

// required uint32 num_devs = 5;
inline bool ModbusParms::_internal_has_num_devs() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ModbusParms::has_num_devs() const {
  return _internal_has_num_devs();
}
inline void ModbusParms::clear_num_devs() {
  num_devs_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::_internal_num_devs() const {
  return num_devs_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::num_devs() const {
  // @@protoc_insertion_point(field_get:ModbusParms.num_devs)
  return _internal_num_devs();
}
inline void ModbusParms::_internal_set_num_devs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  num_devs_ = value;
}
inline void ModbusParms::set_num_devs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_devs(value);
  // @@protoc_insertion_point(field_set:ModbusParms.num_devs)
}

// required uint32 addr = 6;
inline bool ModbusParms::_internal_has_addr() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ModbusParms::has_addr() const {
  return _internal_has_addr();
}
inline void ModbusParms::clear_addr() {
  addr_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::_internal_addr() const {
  return addr_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::addr() const {
  // @@protoc_insertion_point(field_get:ModbusParms.addr)
  return _internal_addr();
}
inline void ModbusParms::_internal_set_addr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  addr_ = value;
}
inline void ModbusParms::set_addr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:ModbusParms.addr)
}

// required string device = 7;
inline bool ModbusParms::_internal_has_device() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModbusParms::has_device() const {
  return _internal_has_device();
}
inline void ModbusParms::clear_device() {
  device_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ModbusParms::device() const {
  // @@protoc_insertion_point(field_get:ModbusParms.device)
  return _internal_device();
}
inline void ModbusParms::set_device(const std::string& value) {
  _internal_set_device(value);
  // @@protoc_insertion_point(field_set:ModbusParms.device)
}
inline std::string* ModbusParms::mutable_device() {
  // @@protoc_insertion_point(field_mutable:ModbusParms.device)
  return _internal_mutable_device();
}
inline const std::string& ModbusParms::_internal_device() const {
  return device_.GetNoArena();
}
inline void ModbusParms::_internal_set_device(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  device_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusParms::set_device(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  device_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusParms.device)
}
inline void ModbusParms::set_device(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  device_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusParms.device)
}
inline void ModbusParms::set_device(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  device_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusParms.device)
}
inline std::string* ModbusParms::_internal_mutable_device() {
  _has_bits_[0] |= 0x00000002u;
  return device_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusParms::release_device() {
  // @@protoc_insertion_point(field_release:ModbusParms.device)
  if (!_internal_has_device()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return device_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusParms::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  device_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:ModbusParms.device)
}

// required string address_list = 8;
inline bool ModbusParms::_internal_has_address_list() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ModbusParms::has_address_list() const {
  return _internal_has_address_list();
}
inline void ModbusParms::clear_address_list() {
  address_list_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ModbusParms::address_list() const {
  // @@protoc_insertion_point(field_get:ModbusParms.address_list)
  return _internal_address_list();
}
inline void ModbusParms::set_address_list(const std::string& value) {
  _internal_set_address_list(value);
  // @@protoc_insertion_point(field_set:ModbusParms.address_list)
}
inline std::string* ModbusParms::mutable_address_list() {
  // @@protoc_insertion_point(field_mutable:ModbusParms.address_list)
  return _internal_mutable_address_list();
}
inline const std::string& ModbusParms::_internal_address_list() const {
  return address_list_.GetNoArena();
}
inline void ModbusParms::_internal_set_address_list(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  address_list_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusParms::set_address_list(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  address_list_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusParms.address_list)
}
inline void ModbusParms::set_address_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  address_list_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusParms.address_list)
}
inline void ModbusParms::set_address_list(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  address_list_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusParms.address_list)
}
inline std::string* ModbusParms::_internal_mutable_address_list() {
  _has_bits_[0] |= 0x00000004u;
  return address_list_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusParms::release_address_list() {
  // @@protoc_insertion_point(field_release:ModbusParms.address_list)
  if (!_internal_has_address_list()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return address_list_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusParms::set_allocated_address_list(std::string* address_list) {
  if (address_list != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  address_list_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address_list);
  // @@protoc_insertion_point(field_set_allocated:ModbusParms.address_list)
}

// required uint32 timeout = 9;
inline bool ModbusParms::_internal_has_timeout() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ModbusParms::has_timeout() const {
  return _internal_has_timeout();
}
inline void ModbusParms::clear_timeout() {
  timeout_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::_internal_timeout() const {
  return timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::timeout() const {
  // @@protoc_insertion_point(field_get:ModbusParms.timeout)
  return _internal_timeout();
}
inline void ModbusParms::_internal_set_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  timeout_ = value;
}
inline void ModbusParms::set_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:ModbusParms.timeout)
}

// required uint32 inter_polling = 10;
inline bool ModbusParms::_internal_has_inter_polling() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ModbusParms::has_inter_polling() const {
  return _internal_has_inter_polling();
}
inline void ModbusParms::clear_inter_polling() {
  inter_polling_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::_internal_inter_polling() const {
  return inter_polling_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::inter_polling() const {
  // @@protoc_insertion_point(field_get:ModbusParms.inter_polling)
  return _internal_inter_polling();
}
inline void ModbusParms::_internal_set_inter_polling(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  inter_polling_ = value;
}
inline void ModbusParms::set_inter_polling(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_inter_polling(value);
  // @@protoc_insertion_point(field_set:ModbusParms.inter_polling)
}

// required uint32 intra_polling = 11;
inline bool ModbusParms::_internal_has_intra_polling() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ModbusParms::has_intra_polling() const {
  return _internal_has_intra_polling();
}
inline void ModbusParms::clear_intra_polling() {
  intra_polling_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::_internal_intra_polling() const {
  return intra_polling_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::intra_polling() const {
  // @@protoc_insertion_point(field_get:ModbusParms.intra_polling)
  return _internal_intra_polling();
}
inline void ModbusParms::_internal_set_intra_polling(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  intra_polling_ = value;
}
inline void ModbusParms::set_intra_polling(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_intra_polling(value);
  // @@protoc_insertion_point(field_set:ModbusParms.intra_polling)
}

// required uint32 retry_timeout = 12;
inline bool ModbusParms::_internal_has_retry_timeout() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ModbusParms::has_retry_timeout() const {
  return _internal_has_retry_timeout();
}
inline void ModbusParms::clear_retry_timeout() {
  retry_timeout_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::_internal_retry_timeout() const {
  return retry_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::retry_timeout() const {
  // @@protoc_insertion_point(field_get:ModbusParms.retry_timeout)
  return _internal_retry_timeout();
}
inline void ModbusParms::_internal_set_retry_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  retry_timeout_ = value;
}
inline void ModbusParms::set_retry_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_retry_timeout(value);
  // @@protoc_insertion_point(field_set:ModbusParms.retry_timeout)
}

// required uint32 retries = 13;
inline bool ModbusParms::_internal_has_retries() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ModbusParms::has_retries() const {
  return _internal_has_retries();
}
inline void ModbusParms::clear_retries() {
  retries_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::_internal_retries() const {
  return retries_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::retries() const {
  // @@protoc_insertion_point(field_get:ModbusParms.retries)
  return _internal_retries();
}
inline void ModbusParms::_internal_set_retries(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  retries_ = value;
}
inline void ModbusParms::set_retries(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_retries(value);
  // @@protoc_insertion_point(field_set:ModbusParms.retries)
}

// required uint32 poll_trigger = 14;
inline bool ModbusParms::_internal_has_poll_trigger() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ModbusParms::has_poll_trigger() const {
  return _internal_has_poll_trigger();
}
inline void ModbusParms::clear_poll_trigger() {
  poll_trigger_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::_internal_poll_trigger() const {
  return poll_trigger_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModbusParms::poll_trigger() const {
  // @@protoc_insertion_point(field_get:ModbusParms.poll_trigger)
  return _internal_poll_trigger();
}
inline void ModbusParms::_internal_set_poll_trigger(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  poll_trigger_ = value;
}
inline void ModbusParms::set_poll_trigger(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_poll_trigger(value);
  // @@protoc_insertion_point(field_set:ModbusParms.poll_trigger)
}

// required string trigger_path = 15;
inline bool ModbusParms::_internal_has_trigger_path() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ModbusParms::has_trigger_path() const {
  return _internal_has_trigger_path();
}
inline void ModbusParms::clear_trigger_path() {
  trigger_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ModbusParms::trigger_path() const {
  // @@protoc_insertion_point(field_get:ModbusParms.trigger_path)
  return _internal_trigger_path();
}
inline void ModbusParms::set_trigger_path(const std::string& value) {
  _internal_set_trigger_path(value);
  // @@protoc_insertion_point(field_set:ModbusParms.trigger_path)
}
inline std::string* ModbusParms::mutable_trigger_path() {
  // @@protoc_insertion_point(field_mutable:ModbusParms.trigger_path)
  return _internal_mutable_trigger_path();
}
inline const std::string& ModbusParms::_internal_trigger_path() const {
  return trigger_path_.GetNoArena();
}
inline void ModbusParms::_internal_set_trigger_path(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  trigger_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusParms::set_trigger_path(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  trigger_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusParms.trigger_path)
}
inline void ModbusParms::set_trigger_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  trigger_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusParms.trigger_path)
}
inline void ModbusParms::set_trigger_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  trigger_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusParms.trigger_path)
}
inline std::string* ModbusParms::_internal_mutable_trigger_path() {
  _has_bits_[0] |= 0x00000008u;
  return trigger_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusParms::release_trigger_path() {
  // @@protoc_insertion_point(field_release:ModbusParms.trigger_path)
  if (!_internal_has_trigger_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return trigger_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusParms::set_allocated_trigger_path(std::string* trigger_path) {
  if (trigger_path != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  trigger_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trigger_path);
  // @@protoc_insertion_point(field_set_allocated:ModbusParms.trigger_path)
}

// -------------------------------------------------------------------

// EquipClass

// required uint32 classId = 1;
inline bool EquipClass::_internal_has_classid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool EquipClass::has_classid() const {
  return _internal_has_classid();
}
inline void EquipClass::clear_classid() {
  classid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EquipClass::_internal_classid() const {
  return classid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EquipClass::classid() const {
  // @@protoc_insertion_point(field_get:EquipClass.classId)
  return _internal_classid();
}
inline void EquipClass::_internal_set_classid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  classid_ = value;
}
inline void EquipClass::set_classid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_classid(value);
  // @@protoc_insertion_point(field_set:EquipClass.classId)
}

// required uint32 typeId = 2;
inline bool EquipClass::_internal_has_typeid_() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool EquipClass::has_typeid_() const {
  return _internal_has_typeid_();
}
inline void EquipClass::clear_typeid_() {
  typeid__ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EquipClass::_internal_typeid_() const {
  return typeid__;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EquipClass::typeid_() const {
  // @@protoc_insertion_point(field_get:EquipClass.typeId)
  return _internal_typeid_();
}
inline void EquipClass::_internal_set_typeid_(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  typeid__ = value;
}
inline void EquipClass::set_typeid_(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_typeid_(value);
  // @@protoc_insertion_point(field_set:EquipClass.typeId)
}

// required uint32 mapId = 3;
inline bool EquipClass::_internal_has_mapid() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool EquipClass::has_mapid() const {
  return _internal_has_mapid();
}
inline void EquipClass::clear_mapid() {
  mapid_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EquipClass::_internal_mapid() const {
  return mapid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EquipClass::mapid() const {
  // @@protoc_insertion_point(field_get:EquipClass.mapId)
  return _internal_mapid();
}
inline void EquipClass::_internal_set_mapid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  mapid_ = value;
}
inline void EquipClass::set_mapid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:EquipClass.mapId)
}

// required string name = 4;
inline bool EquipClass::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EquipClass::has_name() const {
  return _internal_has_name();
}
inline void EquipClass::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EquipClass::name() const {
  // @@protoc_insertion_point(field_get:EquipClass.name)
  return _internal_name();
}
inline void EquipClass::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:EquipClass.name)
}
inline std::string* EquipClass::mutable_name() {
  // @@protoc_insertion_point(field_mutable:EquipClass.name)
  return _internal_mutable_name();
}
inline const std::string& EquipClass::_internal_name() const {
  return name_.GetNoArena();
}
inline void EquipClass::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EquipClass::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EquipClass.name)
}
inline void EquipClass::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EquipClass.name)
}
inline void EquipClass::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EquipClass.name)
}
inline std::string* EquipClass::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EquipClass::release_name() {
  // @@protoc_insertion_point(field_release:EquipClass.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EquipClass::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:EquipClass.name)
}

// required string version = 5;
inline bool EquipClass::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EquipClass::has_version() const {
  return _internal_has_version();
}
inline void EquipClass::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EquipClass::version() const {
  // @@protoc_insertion_point(field_get:EquipClass.version)
  return _internal_version();
}
inline void EquipClass::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:EquipClass.version)
}
inline std::string* EquipClass::mutable_version() {
  // @@protoc_insertion_point(field_mutable:EquipClass.version)
  return _internal_mutable_version();
}
inline const std::string& EquipClass::_internal_version() const {
  return version_.GetNoArena();
}
inline void EquipClass::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EquipClass::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EquipClass.version)
}
inline void EquipClass::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EquipClass.version)
}
inline void EquipClass::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EquipClass.version)
}
inline std::string* EquipClass::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000002u;
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EquipClass::release_version() {
  // @@protoc_insertion_point(field_release:EquipClass.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EquipClass::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:EquipClass.version)
}

// required string classmap_description = 6;
inline bool EquipClass::_internal_has_classmap_description() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EquipClass::has_classmap_description() const {
  return _internal_has_classmap_description();
}
inline void EquipClass::clear_classmap_description() {
  classmap_description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& EquipClass::classmap_description() const {
  // @@protoc_insertion_point(field_get:EquipClass.classmap_description)
  return _internal_classmap_description();
}
inline void EquipClass::set_classmap_description(const std::string& value) {
  _internal_set_classmap_description(value);
  // @@protoc_insertion_point(field_set:EquipClass.classmap_description)
}
inline std::string* EquipClass::mutable_classmap_description() {
  // @@protoc_insertion_point(field_mutable:EquipClass.classmap_description)
  return _internal_mutable_classmap_description();
}
inline const std::string& EquipClass::_internal_classmap_description() const {
  return classmap_description_.GetNoArena();
}
inline void EquipClass::_internal_set_classmap_description(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  classmap_description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EquipClass::set_classmap_description(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  classmap_description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EquipClass.classmap_description)
}
inline void EquipClass::set_classmap_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  classmap_description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EquipClass.classmap_description)
}
inline void EquipClass::set_classmap_description(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  classmap_description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EquipClass.classmap_description)
}
inline std::string* EquipClass::_internal_mutable_classmap_description() {
  _has_bits_[0] |= 0x00000004u;
  return classmap_description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EquipClass::release_classmap_description() {
  // @@protoc_insertion_point(field_release:EquipClass.classmap_description)
  if (!_internal_has_classmap_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return classmap_description_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EquipClass::set_allocated_classmap_description(std::string* classmap_description) {
  if (classmap_description != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  classmap_description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), classmap_description);
  // @@protoc_insertion_point(field_set_allocated:EquipClass.classmap_description)
}

// required string classmap_path = 7;
inline bool EquipClass::_internal_has_classmap_path() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EquipClass::has_classmap_path() const {
  return _internal_has_classmap_path();
}
inline void EquipClass::clear_classmap_path() {
  classmap_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& EquipClass::classmap_path() const {
  // @@protoc_insertion_point(field_get:EquipClass.classmap_path)
  return _internal_classmap_path();
}
inline void EquipClass::set_classmap_path(const std::string& value) {
  _internal_set_classmap_path(value);
  // @@protoc_insertion_point(field_set:EquipClass.classmap_path)
}
inline std::string* EquipClass::mutable_classmap_path() {
  // @@protoc_insertion_point(field_mutable:EquipClass.classmap_path)
  return _internal_mutable_classmap_path();
}
inline const std::string& EquipClass::_internal_classmap_path() const {
  return classmap_path_.GetNoArena();
}
inline void EquipClass::_internal_set_classmap_path(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  classmap_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EquipClass::set_classmap_path(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  classmap_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EquipClass.classmap_path)
}
inline void EquipClass::set_classmap_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  classmap_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EquipClass.classmap_path)
}
inline void EquipClass::set_classmap_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  classmap_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EquipClass.classmap_path)
}
inline std::string* EquipClass::_internal_mutable_classmap_path() {
  _has_bits_[0] |= 0x00000008u;
  return classmap_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EquipClass::release_classmap_path() {
  // @@protoc_insertion_point(field_release:EquipClass.classmap_path)
  if (!_internal_has_classmap_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return classmap_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EquipClass::set_allocated_classmap_path(std::string* classmap_path) {
  if (classmap_path != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  classmap_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), classmap_path);
  // @@protoc_insertion_point(field_set_allocated:EquipClass.classmap_path)
}

// -------------------------------------------------------------------

// Device

// required string name = 1;
inline bool Device::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Device::has_name() const {
  return _internal_has_name();
}
inline void Device::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Device::name() const {
  // @@protoc_insertion_point(field_get:Device.name)
  return _internal_name();
}
inline void Device::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Device.name)
}
inline std::string* Device::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Device.name)
  return _internal_mutable_name();
}
inline const std::string& Device::_internal_name() const {
  return name_.GetNoArena();
}
inline void Device::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Device::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Device.name)
}
inline void Device::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Device.name)
}
inline void Device::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Device.name)
}
inline std::string* Device::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Device::release_name() {
  // @@protoc_insertion_point(field_release:Device.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Device::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Device.name)
}

// required string manufacturer = 2;
inline bool Device::_internal_has_manufacturer() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Device::has_manufacturer() const {
  return _internal_has_manufacturer();
}
inline void Device::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Device::manufacturer() const {
  // @@protoc_insertion_point(field_get:Device.manufacturer)
  return _internal_manufacturer();
}
inline void Device::set_manufacturer(const std::string& value) {
  _internal_set_manufacturer(value);
  // @@protoc_insertion_point(field_set:Device.manufacturer)
}
inline std::string* Device::mutable_manufacturer() {
  // @@protoc_insertion_point(field_mutable:Device.manufacturer)
  return _internal_mutable_manufacturer();
}
inline const std::string& Device::_internal_manufacturer() const {
  return manufacturer_.GetNoArena();
}
inline void Device::_internal_set_manufacturer(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Device::set_manufacturer(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  manufacturer_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Device.manufacturer)
}
inline void Device::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Device.manufacturer)
}
inline void Device::set_manufacturer(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Device.manufacturer)
}
inline std::string* Device::_internal_mutable_manufacturer() {
  _has_bits_[0] |= 0x00000002u;
  return manufacturer_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Device::release_manufacturer() {
  // @@protoc_insertion_point(field_release:Device.manufacturer)
  if (!_internal_has_manufacturer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return manufacturer_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Device::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  manufacturer_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:Device.manufacturer)
}

// required string model = 3;
inline bool Device::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Device::has_model() const {
  return _internal_has_model();
}
inline void Device::clear_model() {
  model_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Device::model() const {
  // @@protoc_insertion_point(field_get:Device.model)
  return _internal_model();
}
inline void Device::set_model(const std::string& value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:Device.model)
}
inline std::string* Device::mutable_model() {
  // @@protoc_insertion_point(field_mutable:Device.model)
  return _internal_mutable_model();
}
inline const std::string& Device::_internal_model() const {
  return model_.GetNoArena();
}
inline void Device::_internal_set_model(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Device::set_model(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  model_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Device.model)
}
inline void Device::set_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Device.model)
}
inline void Device::set_model(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Device.model)
}
inline std::string* Device::_internal_mutable_model() {
  _has_bits_[0] |= 0x00000004u;
  return model_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Device::release_model() {
  // @@protoc_insertion_point(field_release:Device.model)
  if (!_internal_has_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return model_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Device::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  model_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:Device.model)
}

// required uint32 class_id = 4;
inline bool Device::_internal_has_class_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Device::has_class_id() const {
  return _internal_has_class_id();
}
inline void Device::clear_class_id() {
  class_id_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Device::_internal_class_id() const {
  return class_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Device::class_id() const {
  // @@protoc_insertion_point(field_get:Device.class_id)
  return _internal_class_id();
}
inline void Device::_internal_set_class_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  class_id_ = value;
}
inline void Device::set_class_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_class_id(value);
  // @@protoc_insertion_point(field_set:Device.class_id)
}

// required uint32 ug = 5;
inline bool Device::_internal_has_ug() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Device::has_ug() const {
  return _internal_has_ug();
}
inline void Device::clear_ug() {
  ug_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Device::_internal_ug() const {
  return ug_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Device::ug() const {
  // @@protoc_insertion_point(field_get:Device.ug)
  return _internal_ug();
}
inline void Device::_internal_set_ug(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  ug_ = value;
}
inline void Device::set_ug(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ug(value);
  // @@protoc_insertion_point(field_set:Device.ug)
}

// required .ModbusParms modbus_cfg = 6;
inline bool Device::_internal_has_modbus_cfg() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || modbus_cfg_ != nullptr);
  return value;
}
inline bool Device::has_modbus_cfg() const {
  return _internal_has_modbus_cfg();
}
inline void Device::clear_modbus_cfg() {
  if (modbus_cfg_ != nullptr) modbus_cfg_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ModbusParms& Device::_internal_modbus_cfg() const {
  const ::ModbusParms* p = modbus_cfg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ModbusParms*>(
      &::_ModbusParms_default_instance_);
}
inline const ::ModbusParms& Device::modbus_cfg() const {
  // @@protoc_insertion_point(field_get:Device.modbus_cfg)
  return _internal_modbus_cfg();
}
inline ::ModbusParms* Device::release_modbus_cfg() {
  // @@protoc_insertion_point(field_release:Device.modbus_cfg)
  _has_bits_[0] &= ~0x00000008u;
  ::ModbusParms* temp = modbus_cfg_;
  modbus_cfg_ = nullptr;
  return temp;
}
inline ::ModbusParms* Device::_internal_mutable_modbus_cfg() {
  _has_bits_[0] |= 0x00000008u;
  if (modbus_cfg_ == nullptr) {
    auto* p = CreateMaybeMessage<::ModbusParms>(GetArenaNoVirtual());
    modbus_cfg_ = p;
  }
  return modbus_cfg_;
}
inline ::ModbusParms* Device::mutable_modbus_cfg() {
  // @@protoc_insertion_point(field_mutable:Device.modbus_cfg)
  return _internal_mutable_modbus_cfg();
}
inline void Device::set_allocated_modbus_cfg(::ModbusParms* modbus_cfg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete modbus_cfg_;
  }
  if (modbus_cfg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      modbus_cfg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modbus_cfg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  modbus_cfg_ = modbus_cfg;
  // @@protoc_insertion_point(field_set_allocated:Device.modbus_cfg)
}

// required .Dnp3Parms dnp3_cfg = 7;
inline bool Device::_internal_has_dnp3_cfg() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || dnp3_cfg_ != nullptr);
  return value;
}
inline bool Device::has_dnp3_cfg() const {
  return _internal_has_dnp3_cfg();
}
inline void Device::clear_dnp3_cfg() {
  if (dnp3_cfg_ != nullptr) dnp3_cfg_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::Dnp3Parms& Device::_internal_dnp3_cfg() const {
  const ::Dnp3Parms* p = dnp3_cfg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Dnp3Parms*>(
      &::_Dnp3Parms_default_instance_);
}
inline const ::Dnp3Parms& Device::dnp3_cfg() const {
  // @@protoc_insertion_point(field_get:Device.dnp3_cfg)
  return _internal_dnp3_cfg();
}
inline ::Dnp3Parms* Device::release_dnp3_cfg() {
  // @@protoc_insertion_point(field_release:Device.dnp3_cfg)
  _has_bits_[0] &= ~0x00000010u;
  ::Dnp3Parms* temp = dnp3_cfg_;
  dnp3_cfg_ = nullptr;
  return temp;
}
inline ::Dnp3Parms* Device::_internal_mutable_dnp3_cfg() {
  _has_bits_[0] |= 0x00000010u;
  if (dnp3_cfg_ == nullptr) {
    auto* p = CreateMaybeMessage<::Dnp3Parms>(GetArenaNoVirtual());
    dnp3_cfg_ = p;
  }
  return dnp3_cfg_;
}
inline ::Dnp3Parms* Device::mutable_dnp3_cfg() {
  // @@protoc_insertion_point(field_mutable:Device.dnp3_cfg)
  return _internal_mutable_dnp3_cfg();
}
inline void Device::set_allocated_dnp3_cfg(::Dnp3Parms* dnp3_cfg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dnp3_cfg_;
  }
  if (dnp3_cfg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dnp3_cfg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dnp3_cfg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  dnp3_cfg_ = dnp3_cfg;
  // @@protoc_insertion_point(field_set_allocated:Device.dnp3_cfg)
}

// required .EquipClass classmap = 8;
inline bool Device::_internal_has_classmap() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || classmap_ != nullptr);
  return value;
}
inline bool Device::has_classmap() const {
  return _internal_has_classmap();
}
inline void Device::clear_classmap() {
  if (classmap_ != nullptr) classmap_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::EquipClass& Device::_internal_classmap() const {
  const ::EquipClass* p = classmap_;
  return p != nullptr ? *p : *reinterpret_cast<const ::EquipClass*>(
      &::_EquipClass_default_instance_);
}
inline const ::EquipClass& Device::classmap() const {
  // @@protoc_insertion_point(field_get:Device.classmap)
  return _internal_classmap();
}
inline ::EquipClass* Device::release_classmap() {
  // @@protoc_insertion_point(field_release:Device.classmap)
  _has_bits_[0] &= ~0x00000020u;
  ::EquipClass* temp = classmap_;
  classmap_ = nullptr;
  return temp;
}
inline ::EquipClass* Device::_internal_mutable_classmap() {
  _has_bits_[0] |= 0x00000020u;
  if (classmap_ == nullptr) {
    auto* p = CreateMaybeMessage<::EquipClass>(GetArenaNoVirtual());
    classmap_ = p;
  }
  return classmap_;
}
inline ::EquipClass* Device::mutable_classmap() {
  // @@protoc_insertion_point(field_mutable:Device.classmap)
  return _internal_mutable_classmap();
}
inline void Device::set_allocated_classmap(::EquipClass* classmap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete classmap_;
  }
  if (classmap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      classmap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classmap, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  classmap_ = classmap;
  // @@protoc_insertion_point(field_set_allocated:Device.classmap)
}

// -------------------------------------------------------------------

// ConfigGateway

// repeated .Device devices = 1;
inline int ConfigGateway::_internal_devices_size() const {
  return devices_.size();
}
inline int ConfigGateway::devices_size() const {
  return _internal_devices_size();
}
inline void ConfigGateway::clear_devices() {
  devices_.Clear();
}
inline ::Device* ConfigGateway::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:ConfigGateway.devices)
  return devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Device >*
ConfigGateway::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:ConfigGateway.devices)
  return &devices_;
}
inline const ::Device& ConfigGateway::_internal_devices(int index) const {
  return devices_.Get(index);
}
inline const ::Device& ConfigGateway::devices(int index) const {
  // @@protoc_insertion_point(field_get:ConfigGateway.devices)
  return _internal_devices(index);
}
inline ::Device* ConfigGateway::_internal_add_devices() {
  return devices_.Add();
}
inline ::Device* ConfigGateway::add_devices() {
  // @@protoc_insertion_point(field_add:ConfigGateway.devices)
  return _internal_add_devices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Device >&
ConfigGateway::devices() const {
  // @@protoc_insertion_point(field_list:ConfigGateway.devices)
  return devices_;
}

// -------------------------------------------------------------------

// ConfigGatewayResponse

// required uint32 numDevicesCfg = 1;
inline bool ConfigGatewayResponse::_internal_has_numdevicescfg() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigGatewayResponse::has_numdevicescfg() const {
  return _internal_has_numdevicescfg();
}
inline void ConfigGatewayResponse::clear_numdevicescfg() {
  numdevicescfg_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ConfigGatewayResponse::_internal_numdevicescfg() const {
  return numdevicescfg_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ConfigGatewayResponse::numdevicescfg() const {
  // @@protoc_insertion_point(field_get:ConfigGatewayResponse.numDevicesCfg)
  return _internal_numdevicescfg();
}
inline void ConfigGatewayResponse::_internal_set_numdevicescfg(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  numdevicescfg_ = value;
}
inline void ConfigGatewayResponse::set_numdevicescfg(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_numdevicescfg(value);
  // @@protoc_insertion_point(field_set:ConfigGatewayResponse.numDevicesCfg)
}

// required bool success = 2;
inline bool ConfigGatewayResponse::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigGatewayResponse::has_success() const {
  return _internal_has_success();
}
inline void ConfigGatewayResponse::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ConfigGatewayResponse::_internal_success() const {
  return success_;
}
inline bool ConfigGatewayResponse::success() const {
  // @@protoc_insertion_point(field_get:ConfigGatewayResponse.success)
  return _internal_success();
}
inline void ConfigGatewayResponse::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000004u;
  success_ = value;
}
inline void ConfigGatewayResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ConfigGatewayResponse.success)
}

// optional string errMsg = 3;
inline bool ConfigGatewayResponse::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigGatewayResponse::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void ConfigGatewayResponse::clear_errmsg() {
  errmsg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigGatewayResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:ConfigGatewayResponse.errMsg)
  return _internal_errmsg();
}
inline void ConfigGatewayResponse::set_errmsg(const std::string& value) {
  _internal_set_errmsg(value);
  // @@protoc_insertion_point(field_set:ConfigGatewayResponse.errMsg)
}
inline std::string* ConfigGatewayResponse::mutable_errmsg() {
  // @@protoc_insertion_point(field_mutable:ConfigGatewayResponse.errMsg)
  return _internal_mutable_errmsg();
}
inline const std::string& ConfigGatewayResponse::_internal_errmsg() const {
  return errmsg_.GetNoArena();
}
inline void ConfigGatewayResponse::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ConfigGatewayResponse::set_errmsg(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ConfigGatewayResponse.errMsg)
}
inline void ConfigGatewayResponse::set_errmsg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  errmsg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ConfigGatewayResponse.errMsg)
}
inline void ConfigGatewayResponse::set_errmsg(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ConfigGatewayResponse.errMsg)
}
inline std::string* ConfigGatewayResponse::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConfigGatewayResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:ConfigGatewayResponse.errMsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigGatewayResponse::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg);
  // @@protoc_insertion_point(field_set_allocated:ConfigGatewayResponse.errMsg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TDnp3ObjectType_> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TDnp3ObjectType_>() {
  return ::TDnp3ObjectType__descriptor();
}
template <> struct is_proto_enum< ::TModbusTypeConn_> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TModbusTypeConn_>() {
  return ::TModbusTypeConn__descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_config_2eproto
