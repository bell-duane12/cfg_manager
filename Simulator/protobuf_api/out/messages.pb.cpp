// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_messages_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CheckGateway_messages_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_command_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_Commands_command_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_config_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ConfigGateway_config_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_config_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ConfigGatewayResponse_config_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EquipmentStatus_messages_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GatewayStatus_messages_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_header_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HeaderMessage_header_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_NotificationValues_messages_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_objects_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ObjectValues_objects_2eproto;
class GatewayStatusDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GatewayStatus> _instance;
} _GatewayStatus_default_instance_;
class EquipmentStatusDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EquipmentStatus> _instance;
} _EquipmentStatus_default_instance_;
class UploadToGatewayDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UploadToGateway> _instance;
} _UploadToGateway_default_instance_;
class CheckGatewayDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CheckGateway> _instance;
} _CheckGateway_default_instance_;
class UploadToServerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UploadToServer> _instance;
} _UploadToServer_default_instance_;
class NotificationValuesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NotificationValues> _instance;
} _NotificationValues_default_instance_;
class NotificationToServerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NotificationToServer> _instance;
} _NotificationToServer_default_instance_;
static void InitDefaultsscc_info_CheckGateway_messages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CheckGateway_default_instance_;
    new (ptr) ::CheckGateway();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::CheckGateway::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CheckGateway_messages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CheckGateway_messages_2eproto}, {}};

static void InitDefaultsscc_info_EquipmentStatus_messages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_EquipmentStatus_default_instance_;
    new (ptr) ::EquipmentStatus();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::EquipmentStatus::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EquipmentStatus_messages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EquipmentStatus_messages_2eproto}, {}};

static void InitDefaultsscc_info_GatewayStatus_messages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_GatewayStatus_default_instance_;
    new (ptr) ::GatewayStatus();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::GatewayStatus::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GatewayStatus_messages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GatewayStatus_messages_2eproto}, {}};

static void InitDefaultsscc_info_NotificationToServer_messages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_NotificationToServer_default_instance_;
    new (ptr) ::NotificationToServer();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NotificationToServer::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_NotificationToServer_messages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, 0, InitDefaultsscc_info_NotificationToServer_messages_2eproto}, {
      &scc_info_HeaderMessage_header_2eproto.base,
      &scc_info_EquipmentStatus_messages_2eproto.base,
      &scc_info_GatewayStatus_messages_2eproto.base,
      &scc_info_NotificationValues_messages_2eproto.base,}};

static void InitDefaultsscc_info_NotificationValues_messages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_NotificationValues_default_instance_;
    new (ptr) ::NotificationValues();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NotificationValues::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_NotificationValues_messages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_NotificationValues_messages_2eproto}, {
      &scc_info_ObjectValues_objects_2eproto.base,}};

static void InitDefaultsscc_info_UploadToGateway_messages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_UploadToGateway_default_instance_;
    new (ptr) ::UploadToGateway();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::UploadToGateway::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_UploadToGateway_messages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 5, 0, InitDefaultsscc_info_UploadToGateway_messages_2eproto}, {
      &scc_info_HeaderMessage_header_2eproto.base,
      &scc_info_ConfigGateway_config_2eproto.base,
      &scc_info_Commands_command_2eproto.base,
      &scc_info_CheckGateway_messages_2eproto.base,
      &scc_info_EquipmentStatus_messages_2eproto.base,}};

static void InitDefaultsscc_info_UploadToServer_messages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_UploadToServer_default_instance_;
    new (ptr) ::UploadToServer();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::UploadToServer::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_UploadToServer_messages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 5, 0, InitDefaultsscc_info_UploadToServer_messages_2eproto}, {
      &scc_info_HeaderMessage_header_2eproto.base,
      &scc_info_GatewayStatus_messages_2eproto.base,
      &scc_info_EquipmentStatus_messages_2eproto.base,
      &scc_info_ConfigGatewayResponse_config_2eproto.base,
      &scc_info_Commands_command_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_messages_2eproto[7];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_messages_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_messages_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_messages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::GatewayStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::GatewayStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::GatewayStatus, configured_),
  PROTOBUF_FIELD_OFFSET(::GatewayStatus, uptime_),
  PROTOBUF_FIELD_OFFSET(::GatewayStatus, timestamp_),
  PROTOBUF_FIELD_OFFSET(::GatewayStatus, online_),
  2,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::EquipmentStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::EquipmentStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::EquipmentStatus, online_),
  PROTOBUF_FIELD_OFFSET(::EquipmentStatus, commuptime_),
  PROTOBUF_FIELD_OFFSET(::EquipmentStatus, uns_),
  PROTOBUF_FIELD_OFFSET(::EquipmentStatus, timestamp_),
  2,
  0,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::UploadToGateway, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::UploadToGateway, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::UploadToGateway, header_),
  PROTOBUF_FIELD_OFFSET(::UploadToGateway, configgw_),
  PROTOBUF_FIELD_OFFSET(::UploadToGateway, cmd_),
  PROTOBUF_FIELD_OFFSET(::UploadToGateway, checkgw_),
  PROTOBUF_FIELD_OFFSET(::UploadToGateway, eqpstatus_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CheckGateway, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CheckGateway, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CheckGateway, isalive_),
  0,
  PROTOBUF_FIELD_OFFSET(::UploadToServer, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::UploadToServer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::UploadToServer, header_),
  PROTOBUF_FIELD_OFFSET(::UploadToServer, gwstatus_),
  PROTOBUF_FIELD_OFFSET(::UploadToServer, eqpstatus_),
  PROTOBUF_FIELD_OFFSET(::UploadToServer, configgwresponse_),
  PROTOBUF_FIELD_OFFSET(::UploadToServer, cmd_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::NotificationValues, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::NotificationValues, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::NotificationValues, alarmlist_),
  PROTOBUF_FIELD_OFFSET(::NotificationValues, staticlist_),
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::NotificationToServer, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::NotificationToServer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::NotificationToServer, header_),
  PROTOBUF_FIELD_OFFSET(::NotificationToServer, eqpstatus_),
  PROTOBUF_FIELD_OFFSET(::NotificationToServer, gwstatus_),
  PROTOBUF_FIELD_OFFSET(::NotificationToServer, notificationval_),
  0,
  1,
  2,
  3,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, sizeof(::GatewayStatus)},
  { 13, 22, sizeof(::EquipmentStatus)},
  { 26, 36, sizeof(::UploadToGateway)},
  { 41, 47, sizeof(::CheckGateway)},
  { 48, 58, sizeof(::UploadToServer)},
  { 63, 70, sizeof(::NotificationValues)},
  { 72, 81, sizeof(::NotificationToServer)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_GatewayStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_EquipmentStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_UploadToGateway_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CheckGateway_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_UploadToServer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_NotificationValues_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_NotificationToServer_default_instance_),
};

const char descriptor_table_protodef_messages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016messages.proto\032\014header.proto\032\014config.p"
  "roto\032\rcommand.proto\032\robjects.proto\"V\n\rGa"
  "tewayStatus\022\022\n\nconfigured\030\001 \001(\010\022\016\n\006uptim"
  "e\030\002 \001(\003\022\021\n\ttimeStamp\030\003 \001(\003\022\016\n\006online\030\004 \001"
  "(\010\"U\n\017EquipmentStatus\022\016\n\006online\030\001 \001(\010\022\022\n"
  "\ncommUpTime\030\002 \001(\003\022\013\n\003UNS\030\003 \001(\010\022\021\n\ttimeSt"
  "amp\030\004 \001(\003\"\260\001\n\017UploadToGateway\022\036\n\006header\030"
  "\001 \002(\0132\016.HeaderMessage\022 \n\010configGw\030\002 \001(\0132"
  "\016.ConfigGateway\022\026\n\003cmd\030\003 \001(\0132\t.Commands\022"
  "\036\n\007checkGw\030\004 \001(\0132\r.CheckGateway\022#\n\teqpSt"
  "atus\030\005 \001(\0132\020.EquipmentStatus\"\037\n\014CheckGat"
  "eway\022\017\n\007isAlive\030\001 \002(\010\"\301\001\n\016UploadToServer"
  "\022\036\n\006header\030\001 \002(\0132\016.HeaderMessage\022 \n\010gwSt"
  "atus\030\002 \001(\0132\016.GatewayStatus\022#\n\teqpStatus\030"
  "\003 \001(\0132\020.EquipmentStatus\0220\n\020configGwRespo"
  "nse\030\004 \001(\0132\026.ConfigGatewayResponse\022\026\n\003cmd"
  "\030\005 \001(\0132\t.Commands\"Y\n\022NotificationValues\022"
  " \n\talarmList\030\001 \003(\0132\r.ObjectValues\022!\n\nsta"
  "ticList\030\002 \003(\0132\r.ObjectValues\"\253\001\n\024Notific"
  "ationToServer\022\036\n\006header\030\001 \002(\0132\016.HeaderMe"
  "ssage\022#\n\teqpStatus\030\002 \001(\0132\020.EquipmentStat"
  "us\022 \n\010gwStatus\030\003 \001(\0132\016.GatewayStatus\022,\n\017"
  "notificationval\030\004 \001(\0132\023.NotificationValu"
  "es"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_messages_2eproto_deps[4] = {
  &::descriptor_table_command_2eproto,
  &::descriptor_table_config_2eproto,
  &::descriptor_table_header_2eproto,
  &::descriptor_table_objects_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_messages_2eproto_sccs[7] = {
  &scc_info_CheckGateway_messages_2eproto.base,
  &scc_info_EquipmentStatus_messages_2eproto.base,
  &scc_info_GatewayStatus_messages_2eproto.base,
  &scc_info_NotificationToServer_messages_2eproto.base,
  &scc_info_NotificationValues_messages_2eproto.base,
  &scc_info_UploadToGateway_messages_2eproto.base,
  &scc_info_UploadToServer_messages_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_messages_2eproto_once;
static bool descriptor_table_messages_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2eproto = {
  &descriptor_table_messages_2eproto_initialized, descriptor_table_protodef_messages_2eproto, "messages.proto", 922,
  &descriptor_table_messages_2eproto_once, descriptor_table_messages_2eproto_sccs, descriptor_table_messages_2eproto_deps, 7, 4,
  schemas, file_default_instances, TableStruct_messages_2eproto::offsets,
  file_level_metadata_messages_2eproto, 7, file_level_enum_descriptors_messages_2eproto, file_level_service_descriptors_messages_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_messages_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_messages_2eproto), true);

// ===================================================================

void GatewayStatus::InitAsDefaultInstance() {
}
class GatewayStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<GatewayStatus>()._has_bits_);
  static void set_has_configured(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_uptime(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_online(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

GatewayStatus::GatewayStatus()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GatewayStatus)
}
GatewayStatus::GatewayStatus(const GatewayStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&uptime_, &from.uptime_,
    static_cast<size_t>(reinterpret_cast<char*>(&online_) -
    reinterpret_cast<char*>(&uptime_)) + sizeof(online_));
  // @@protoc_insertion_point(copy_constructor:GatewayStatus)
}

void GatewayStatus::SharedCtor() {
  ::memset(&uptime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&online_) -
      reinterpret_cast<char*>(&uptime_)) + sizeof(online_));
}

GatewayStatus::~GatewayStatus() {
  // @@protoc_insertion_point(destructor:GatewayStatus)
  SharedDtor();
}

void GatewayStatus::SharedDtor() {
}

void GatewayStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GatewayStatus& GatewayStatus::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GatewayStatus_messages_2eproto.base);
  return *internal_default_instance();
}


void GatewayStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:GatewayStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&uptime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&online_) -
        reinterpret_cast<char*>(&uptime_)) + sizeof(online_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* GatewayStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool configured = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_configured(&has_bits);
          configured_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 uptime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_uptime(&has_bits);
          uptime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 timeStamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool online = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_online(&has_bits);
          online_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GatewayStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GatewayStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool configured = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_configured(), target);
  }

  // optional int64 uptime = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_uptime(), target);
  }

  // optional int64 timeStamp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_timestamp(), target);
  }

  // optional bool online = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_online(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GatewayStatus)
  return target;
}

size_t GatewayStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GatewayStatus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 uptime = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_uptime());
    }

    // optional int64 timeStamp = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_timestamp());
    }

    // optional bool configured = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool online = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GatewayStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:GatewayStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const GatewayStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GatewayStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:GatewayStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:GatewayStatus)
    MergeFrom(*source);
  }
}

void GatewayStatus::MergeFrom(const GatewayStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GatewayStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      uptime_ = from.uptime_;
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      configured_ = from.configured_;
    }
    if (cached_has_bits & 0x00000008u) {
      online_ = from.online_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GatewayStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:GatewayStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GatewayStatus::CopyFrom(const GatewayStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GatewayStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GatewayStatus::IsInitialized() const {
  return true;
}

void GatewayStatus::InternalSwap(GatewayStatus* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(uptime_, other->uptime_);
  swap(timestamp_, other->timestamp_);
  swap(configured_, other->configured_);
  swap(online_, other->online_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GatewayStatus::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void EquipmentStatus::InitAsDefaultInstance() {
}
class EquipmentStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<EquipmentStatus>()._has_bits_);
  static void set_has_online(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_commuptime(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_uns(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

EquipmentStatus::EquipmentStatus()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:EquipmentStatus)
}
EquipmentStatus::EquipmentStatus(const EquipmentStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&commuptime_, &from.commuptime_,
    static_cast<size_t>(reinterpret_cast<char*>(&uns_) -
    reinterpret_cast<char*>(&commuptime_)) + sizeof(uns_));
  // @@protoc_insertion_point(copy_constructor:EquipmentStatus)
}

void EquipmentStatus::SharedCtor() {
  ::memset(&commuptime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&uns_) -
      reinterpret_cast<char*>(&commuptime_)) + sizeof(uns_));
}

EquipmentStatus::~EquipmentStatus() {
  // @@protoc_insertion_point(destructor:EquipmentStatus)
  SharedDtor();
}

void EquipmentStatus::SharedDtor() {
}

void EquipmentStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EquipmentStatus& EquipmentStatus::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EquipmentStatus_messages_2eproto.base);
  return *internal_default_instance();
}


void EquipmentStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:EquipmentStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&commuptime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&uns_) -
        reinterpret_cast<char*>(&commuptime_)) + sizeof(uns_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* EquipmentStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool online = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_online(&has_bits);
          online_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 commUpTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_commuptime(&has_bits);
          commuptime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool UNS = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_uns(&has_bits);
          uns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 timeStamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EquipmentStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:EquipmentStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool online = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_online(), target);
  }

  // optional int64 commUpTime = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_commuptime(), target);
  }

  // optional bool UNS = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_uns(), target);
  }

  // optional int64 timeStamp = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EquipmentStatus)
  return target;
}

size_t EquipmentStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:EquipmentStatus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 commUpTime = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_commuptime());
    }

    // optional int64 timeStamp = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_timestamp());
    }

    // optional bool online = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool UNS = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EquipmentStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:EquipmentStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const EquipmentStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EquipmentStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:EquipmentStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:EquipmentStatus)
    MergeFrom(*source);
  }
}

void EquipmentStatus::MergeFrom(const EquipmentStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:EquipmentStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      commuptime_ = from.commuptime_;
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      online_ = from.online_;
    }
    if (cached_has_bits & 0x00000008u) {
      uns_ = from.uns_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EquipmentStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:EquipmentStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EquipmentStatus::CopyFrom(const EquipmentStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:EquipmentStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EquipmentStatus::IsInitialized() const {
  return true;
}

void EquipmentStatus::InternalSwap(EquipmentStatus* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(commuptime_, other->commuptime_);
  swap(timestamp_, other->timestamp_);
  swap(online_, other->online_);
  swap(uns_, other->uns_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EquipmentStatus::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UploadToGateway::InitAsDefaultInstance() {
  ::_UploadToGateway_default_instance_._instance.get_mutable()->header_ = const_cast< ::HeaderMessage*>(
      ::HeaderMessage::internal_default_instance());
  ::_UploadToGateway_default_instance_._instance.get_mutable()->configgw_ = const_cast< ::ConfigGateway*>(
      ::ConfigGateway::internal_default_instance());
  ::_UploadToGateway_default_instance_._instance.get_mutable()->cmd_ = const_cast< ::Commands*>(
      ::Commands::internal_default_instance());
  ::_UploadToGateway_default_instance_._instance.get_mutable()->checkgw_ = const_cast< ::CheckGateway*>(
      ::CheckGateway::internal_default_instance());
  ::_UploadToGateway_default_instance_._instance.get_mutable()->eqpstatus_ = const_cast< ::EquipmentStatus*>(
      ::EquipmentStatus::internal_default_instance());
}
class UploadToGateway::_Internal {
 public:
  using HasBits = decltype(std::declval<UploadToGateway>()._has_bits_);
  static const ::HeaderMessage& header(const UploadToGateway* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ConfigGateway& configgw(const UploadToGateway* msg);
  static void set_has_configgw(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Commands& cmd(const UploadToGateway* msg);
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CheckGateway& checkgw(const UploadToGateway* msg);
  static void set_has_checkgw(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::EquipmentStatus& eqpstatus(const UploadToGateway* msg);
  static void set_has_eqpstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::HeaderMessage&
UploadToGateway::_Internal::header(const UploadToGateway* msg) {
  return *msg->header_;
}
const ::ConfigGateway&
UploadToGateway::_Internal::configgw(const UploadToGateway* msg) {
  return *msg->configgw_;
}
const ::Commands&
UploadToGateway::_Internal::cmd(const UploadToGateway* msg) {
  return *msg->cmd_;
}
const ::CheckGateway&
UploadToGateway::_Internal::checkgw(const UploadToGateway* msg) {
  return *msg->checkgw_;
}
const ::EquipmentStatus&
UploadToGateway::_Internal::eqpstatus(const UploadToGateway* msg) {
  return *msg->eqpstatus_;
}
void UploadToGateway::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void UploadToGateway::clear_configgw() {
  if (configgw_ != nullptr) configgw_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void UploadToGateway::clear_cmd() {
  if (cmd_ != nullptr) cmd_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
UploadToGateway::UploadToGateway()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:UploadToGateway)
}
UploadToGateway::UploadToGateway(const UploadToGateway& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::HeaderMessage(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_configgw()) {
    configgw_ = new ::ConfigGateway(*from.configgw_);
  } else {
    configgw_ = nullptr;
  }
  if (from._internal_has_cmd()) {
    cmd_ = new ::Commands(*from.cmd_);
  } else {
    cmd_ = nullptr;
  }
  if (from._internal_has_checkgw()) {
    checkgw_ = new ::CheckGateway(*from.checkgw_);
  } else {
    checkgw_ = nullptr;
  }
  if (from._internal_has_eqpstatus()) {
    eqpstatus_ = new ::EquipmentStatus(*from.eqpstatus_);
  } else {
    eqpstatus_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:UploadToGateway)
}

void UploadToGateway::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UploadToGateway_messages_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&eqpstatus_) -
      reinterpret_cast<char*>(&header_)) + sizeof(eqpstatus_));
}

UploadToGateway::~UploadToGateway() {
  // @@protoc_insertion_point(destructor:UploadToGateway)
  SharedDtor();
}

void UploadToGateway::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete configgw_;
  if (this != internal_default_instance()) delete cmd_;
  if (this != internal_default_instance()) delete checkgw_;
  if (this != internal_default_instance()) delete eqpstatus_;
}

void UploadToGateway::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UploadToGateway& UploadToGateway::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UploadToGateway_messages_2eproto.base);
  return *internal_default_instance();
}


void UploadToGateway::Clear() {
// @@protoc_insertion_point(message_clear_start:UploadToGateway)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(configgw_ != nullptr);
      configgw_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(cmd_ != nullptr);
      cmd_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(checkgw_ != nullptr);
      checkgw_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(eqpstatus_ != nullptr);
      eqpstatus_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* UploadToGateway::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .HeaderMessage header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ConfigGateway configGw = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_configgw(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Commands cmd = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cmd(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CheckGateway checkGw = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_checkgw(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .EquipmentStatus eqpStatus = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_eqpstatus(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UploadToGateway::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UploadToGateway)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .HeaderMessage header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // optional .ConfigGateway configGw = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::configgw(this), target, stream);
  }

  // optional .Commands cmd = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::cmd(this), target, stream);
  }

  // optional .CheckGateway checkGw = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::checkgw(this), target, stream);
  }

  // optional .EquipmentStatus eqpStatus = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::eqpstatus(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UploadToGateway)
  return target;
}

size_t UploadToGateway::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UploadToGateway)
  size_t total_size = 0;

  // required .HeaderMessage header = 1;
  if (_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .ConfigGateway configGw = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *configgw_);
    }

    // optional .Commands cmd = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cmd_);
    }

    // optional .CheckGateway checkGw = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *checkgw_);
    }

    // optional .EquipmentStatus eqpStatus = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *eqpstatus_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UploadToGateway::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:UploadToGateway)
  GOOGLE_DCHECK_NE(&from, this);
  const UploadToGateway* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UploadToGateway>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:UploadToGateway)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:UploadToGateway)
    MergeFrom(*source);
  }
}

void UploadToGateway::MergeFrom(const UploadToGateway& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:UploadToGateway)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::HeaderMessage::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_configgw()->::ConfigGateway::MergeFrom(from._internal_configgw());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_cmd()->::Commands::MergeFrom(from._internal_cmd());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_checkgw()->::CheckGateway::MergeFrom(from._internal_checkgw());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_eqpstatus()->::EquipmentStatus::MergeFrom(from._internal_eqpstatus());
    }
  }
}

void UploadToGateway::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:UploadToGateway)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UploadToGateway::CopyFrom(const UploadToGateway& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UploadToGateway)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UploadToGateway::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (_internal_has_header()) {
    if (!header_->IsInitialized()) return false;
  }
  if (_internal_has_configgw()) {
    if (!configgw_->IsInitialized()) return false;
  }
  if (_internal_has_cmd()) {
    if (!cmd_->IsInitialized()) return false;
  }
  if (_internal_has_checkgw()) {
    if (!checkgw_->IsInitialized()) return false;
  }
  return true;
}

void UploadToGateway::InternalSwap(UploadToGateway* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(header_, other->header_);
  swap(configgw_, other->configgw_);
  swap(cmd_, other->cmd_);
  swap(checkgw_, other->checkgw_);
  swap(eqpstatus_, other->eqpstatus_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UploadToGateway::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CheckGateway::InitAsDefaultInstance() {
}
class CheckGateway::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckGateway>()._has_bits_);
  static void set_has_isalive(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CheckGateway::CheckGateway()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CheckGateway)
}
CheckGateway::CheckGateway(const CheckGateway& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  isalive_ = from.isalive_;
  // @@protoc_insertion_point(copy_constructor:CheckGateway)
}

void CheckGateway::SharedCtor() {
  isalive_ = false;
}

CheckGateway::~CheckGateway() {
  // @@protoc_insertion_point(destructor:CheckGateway)
  SharedDtor();
}

void CheckGateway::SharedDtor() {
}

void CheckGateway::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CheckGateway& CheckGateway::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CheckGateway_messages_2eproto.base);
  return *internal_default_instance();
}


void CheckGateway::Clear() {
// @@protoc_insertion_point(message_clear_start:CheckGateway)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  isalive_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* CheckGateway::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool isAlive = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_isalive(&has_bits);
          isalive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CheckGateway::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CheckGateway)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool isAlive = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_isalive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CheckGateway)
  return target;
}

size_t CheckGateway::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CheckGateway)
  size_t total_size = 0;

  // required bool isAlive = 1;
  if (_internal_has_isalive()) {
    total_size += 1 + 1;
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckGateway::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CheckGateway)
  GOOGLE_DCHECK_NE(&from, this);
  const CheckGateway* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CheckGateway>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CheckGateway)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CheckGateway)
    MergeFrom(*source);
  }
}

void CheckGateway::MergeFrom(const CheckGateway& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CheckGateway)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_isalive()) {
    _internal_set_isalive(from._internal_isalive());
  }
}

void CheckGateway::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CheckGateway)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckGateway::CopyFrom(const CheckGateway& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CheckGateway)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckGateway::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void CheckGateway::InternalSwap(CheckGateway* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(isalive_, other->isalive_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckGateway::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UploadToServer::InitAsDefaultInstance() {
  ::_UploadToServer_default_instance_._instance.get_mutable()->header_ = const_cast< ::HeaderMessage*>(
      ::HeaderMessage::internal_default_instance());
  ::_UploadToServer_default_instance_._instance.get_mutable()->gwstatus_ = const_cast< ::GatewayStatus*>(
      ::GatewayStatus::internal_default_instance());
  ::_UploadToServer_default_instance_._instance.get_mutable()->eqpstatus_ = const_cast< ::EquipmentStatus*>(
      ::EquipmentStatus::internal_default_instance());
  ::_UploadToServer_default_instance_._instance.get_mutable()->configgwresponse_ = const_cast< ::ConfigGatewayResponse*>(
      ::ConfigGatewayResponse::internal_default_instance());
  ::_UploadToServer_default_instance_._instance.get_mutable()->cmd_ = const_cast< ::Commands*>(
      ::Commands::internal_default_instance());
}
class UploadToServer::_Internal {
 public:
  using HasBits = decltype(std::declval<UploadToServer>()._has_bits_);
  static const ::HeaderMessage& header(const UploadToServer* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::GatewayStatus& gwstatus(const UploadToServer* msg);
  static void set_has_gwstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::EquipmentStatus& eqpstatus(const UploadToServer* msg);
  static void set_has_eqpstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ConfigGatewayResponse& configgwresponse(const UploadToServer* msg);
  static void set_has_configgwresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::Commands& cmd(const UploadToServer* msg);
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::HeaderMessage&
UploadToServer::_Internal::header(const UploadToServer* msg) {
  return *msg->header_;
}
const ::GatewayStatus&
UploadToServer::_Internal::gwstatus(const UploadToServer* msg) {
  return *msg->gwstatus_;
}
const ::EquipmentStatus&
UploadToServer::_Internal::eqpstatus(const UploadToServer* msg) {
  return *msg->eqpstatus_;
}
const ::ConfigGatewayResponse&
UploadToServer::_Internal::configgwresponse(const UploadToServer* msg) {
  return *msg->configgwresponse_;
}
const ::Commands&
UploadToServer::_Internal::cmd(const UploadToServer* msg) {
  return *msg->cmd_;
}
void UploadToServer::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void UploadToServer::clear_configgwresponse() {
  if (configgwresponse_ != nullptr) configgwresponse_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void UploadToServer::clear_cmd() {
  if (cmd_ != nullptr) cmd_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
UploadToServer::UploadToServer()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:UploadToServer)
}
UploadToServer::UploadToServer(const UploadToServer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::HeaderMessage(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_gwstatus()) {
    gwstatus_ = new ::GatewayStatus(*from.gwstatus_);
  } else {
    gwstatus_ = nullptr;
  }
  if (from._internal_has_eqpstatus()) {
    eqpstatus_ = new ::EquipmentStatus(*from.eqpstatus_);
  } else {
    eqpstatus_ = nullptr;
  }
  if (from._internal_has_configgwresponse()) {
    configgwresponse_ = new ::ConfigGatewayResponse(*from.configgwresponse_);
  } else {
    configgwresponse_ = nullptr;
  }
  if (from._internal_has_cmd()) {
    cmd_ = new ::Commands(*from.cmd_);
  } else {
    cmd_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:UploadToServer)
}

void UploadToServer::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UploadToServer_messages_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cmd_) -
      reinterpret_cast<char*>(&header_)) + sizeof(cmd_));
}

UploadToServer::~UploadToServer() {
  // @@protoc_insertion_point(destructor:UploadToServer)
  SharedDtor();
}

void UploadToServer::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete gwstatus_;
  if (this != internal_default_instance()) delete eqpstatus_;
  if (this != internal_default_instance()) delete configgwresponse_;
  if (this != internal_default_instance()) delete cmd_;
}

void UploadToServer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UploadToServer& UploadToServer::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UploadToServer_messages_2eproto.base);
  return *internal_default_instance();
}


void UploadToServer::Clear() {
// @@protoc_insertion_point(message_clear_start:UploadToServer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(gwstatus_ != nullptr);
      gwstatus_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(eqpstatus_ != nullptr);
      eqpstatus_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(configgwresponse_ != nullptr);
      configgwresponse_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(cmd_ != nullptr);
      cmd_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* UploadToServer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .HeaderMessage header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .GatewayStatus gwStatus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_gwstatus(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .EquipmentStatus eqpStatus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_eqpstatus(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ConfigGatewayResponse configGwResponse = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_configgwresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Commands cmd = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_cmd(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UploadToServer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UploadToServer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .HeaderMessage header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // optional .GatewayStatus gwStatus = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::gwstatus(this), target, stream);
  }

  // optional .EquipmentStatus eqpStatus = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::eqpstatus(this), target, stream);
  }

  // optional .ConfigGatewayResponse configGwResponse = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::configgwresponse(this), target, stream);
  }

  // optional .Commands cmd = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::cmd(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UploadToServer)
  return target;
}

size_t UploadToServer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UploadToServer)
  size_t total_size = 0;

  // required .HeaderMessage header = 1;
  if (_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .GatewayStatus gwStatus = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gwstatus_);
    }

    // optional .EquipmentStatus eqpStatus = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *eqpstatus_);
    }

    // optional .ConfigGatewayResponse configGwResponse = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *configgwresponse_);
    }

    // optional .Commands cmd = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cmd_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UploadToServer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:UploadToServer)
  GOOGLE_DCHECK_NE(&from, this);
  const UploadToServer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UploadToServer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:UploadToServer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:UploadToServer)
    MergeFrom(*source);
  }
}

void UploadToServer::MergeFrom(const UploadToServer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:UploadToServer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::HeaderMessage::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_gwstatus()->::GatewayStatus::MergeFrom(from._internal_gwstatus());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_eqpstatus()->::EquipmentStatus::MergeFrom(from._internal_eqpstatus());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_configgwresponse()->::ConfigGatewayResponse::MergeFrom(from._internal_configgwresponse());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_cmd()->::Commands::MergeFrom(from._internal_cmd());
    }
  }
}

void UploadToServer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:UploadToServer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UploadToServer::CopyFrom(const UploadToServer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UploadToServer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UploadToServer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (_internal_has_header()) {
    if (!header_->IsInitialized()) return false;
  }
  if (_internal_has_configgwresponse()) {
    if (!configgwresponse_->IsInitialized()) return false;
  }
  if (_internal_has_cmd()) {
    if (!cmd_->IsInitialized()) return false;
  }
  return true;
}

void UploadToServer::InternalSwap(UploadToServer* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(header_, other->header_);
  swap(gwstatus_, other->gwstatus_);
  swap(eqpstatus_, other->eqpstatus_);
  swap(configgwresponse_, other->configgwresponse_);
  swap(cmd_, other->cmd_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UploadToServer::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void NotificationValues::InitAsDefaultInstance() {
}
class NotificationValues::_Internal {
 public:
  using HasBits = decltype(std::declval<NotificationValues>()._has_bits_);
};

void NotificationValues::clear_alarmlist() {
  alarmlist_.Clear();
}
void NotificationValues::clear_staticlist() {
  staticlist_.Clear();
}
NotificationValues::NotificationValues()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NotificationValues)
}
NotificationValues::NotificationValues(const NotificationValues& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      alarmlist_(from.alarmlist_),
      staticlist_(from.staticlist_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:NotificationValues)
}

void NotificationValues::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_NotificationValues_messages_2eproto.base);
}

NotificationValues::~NotificationValues() {
  // @@protoc_insertion_point(destructor:NotificationValues)
  SharedDtor();
}

void NotificationValues::SharedDtor() {
}

void NotificationValues::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NotificationValues& NotificationValues::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_NotificationValues_messages_2eproto.base);
  return *internal_default_instance();
}


void NotificationValues::Clear() {
// @@protoc_insertion_point(message_clear_start:NotificationValues)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alarmlist_.Clear();
  staticlist_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* NotificationValues::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .ObjectValues alarmList = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_alarmlist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .ObjectValues staticList = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_staticlist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NotificationValues::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NotificationValues)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ObjectValues alarmList = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_alarmlist_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_alarmlist(i), target, stream);
  }

  // repeated .ObjectValues staticList = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_staticlist_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_staticlist(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NotificationValues)
  return target;
}

size_t NotificationValues::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NotificationValues)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ObjectValues alarmList = 1;
  total_size += 1UL * this->_internal_alarmlist_size();
  for (const auto& msg : this->alarmlist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ObjectValues staticList = 2;
  total_size += 1UL * this->_internal_staticlist_size();
  for (const auto& msg : this->staticlist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NotificationValues::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NotificationValues)
  GOOGLE_DCHECK_NE(&from, this);
  const NotificationValues* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NotificationValues>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NotificationValues)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NotificationValues)
    MergeFrom(*source);
  }
}

void NotificationValues::MergeFrom(const NotificationValues& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NotificationValues)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  alarmlist_.MergeFrom(from.alarmlist_);
  staticlist_.MergeFrom(from.staticlist_);
}

void NotificationValues::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NotificationValues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotificationValues::CopyFrom(const NotificationValues& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NotificationValues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotificationValues::IsInitialized() const {
  return true;
}

void NotificationValues::InternalSwap(NotificationValues* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  alarmlist_.InternalSwap(&other->alarmlist_);
  staticlist_.InternalSwap(&other->staticlist_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NotificationValues::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void NotificationToServer::InitAsDefaultInstance() {
  ::_NotificationToServer_default_instance_._instance.get_mutable()->header_ = const_cast< ::HeaderMessage*>(
      ::HeaderMessage::internal_default_instance());
  ::_NotificationToServer_default_instance_._instance.get_mutable()->eqpstatus_ = const_cast< ::EquipmentStatus*>(
      ::EquipmentStatus::internal_default_instance());
  ::_NotificationToServer_default_instance_._instance.get_mutable()->gwstatus_ = const_cast< ::GatewayStatus*>(
      ::GatewayStatus::internal_default_instance());
  ::_NotificationToServer_default_instance_._instance.get_mutable()->notificationval_ = const_cast< ::NotificationValues*>(
      ::NotificationValues::internal_default_instance());
}
class NotificationToServer::_Internal {
 public:
  using HasBits = decltype(std::declval<NotificationToServer>()._has_bits_);
  static const ::HeaderMessage& header(const NotificationToServer* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::EquipmentStatus& eqpstatus(const NotificationToServer* msg);
  static void set_has_eqpstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::GatewayStatus& gwstatus(const NotificationToServer* msg);
  static void set_has_gwstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::NotificationValues& notificationval(const NotificationToServer* msg);
  static void set_has_notificationval(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::HeaderMessage&
NotificationToServer::_Internal::header(const NotificationToServer* msg) {
  return *msg->header_;
}
const ::EquipmentStatus&
NotificationToServer::_Internal::eqpstatus(const NotificationToServer* msg) {
  return *msg->eqpstatus_;
}
const ::GatewayStatus&
NotificationToServer::_Internal::gwstatus(const NotificationToServer* msg) {
  return *msg->gwstatus_;
}
const ::NotificationValues&
NotificationToServer::_Internal::notificationval(const NotificationToServer* msg) {
  return *msg->notificationval_;
}
void NotificationToServer::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
NotificationToServer::NotificationToServer()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NotificationToServer)
}
NotificationToServer::NotificationToServer(const NotificationToServer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::HeaderMessage(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_eqpstatus()) {
    eqpstatus_ = new ::EquipmentStatus(*from.eqpstatus_);
  } else {
    eqpstatus_ = nullptr;
  }
  if (from._internal_has_gwstatus()) {
    gwstatus_ = new ::GatewayStatus(*from.gwstatus_);
  } else {
    gwstatus_ = nullptr;
  }
  if (from._internal_has_notificationval()) {
    notificationval_ = new ::NotificationValues(*from.notificationval_);
  } else {
    notificationval_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:NotificationToServer)
}

void NotificationToServer::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_NotificationToServer_messages_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&notificationval_) -
      reinterpret_cast<char*>(&header_)) + sizeof(notificationval_));
}

NotificationToServer::~NotificationToServer() {
  // @@protoc_insertion_point(destructor:NotificationToServer)
  SharedDtor();
}

void NotificationToServer::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete eqpstatus_;
  if (this != internal_default_instance()) delete gwstatus_;
  if (this != internal_default_instance()) delete notificationval_;
}

void NotificationToServer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NotificationToServer& NotificationToServer::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_NotificationToServer_messages_2eproto.base);
  return *internal_default_instance();
}


void NotificationToServer::Clear() {
// @@protoc_insertion_point(message_clear_start:NotificationToServer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(eqpstatus_ != nullptr);
      eqpstatus_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(gwstatus_ != nullptr);
      gwstatus_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(notificationval_ != nullptr);
      notificationval_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* NotificationToServer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .HeaderMessage header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .EquipmentStatus eqpStatus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_eqpstatus(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .GatewayStatus gwStatus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_gwstatus(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .NotificationValues notificationval = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_notificationval(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NotificationToServer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NotificationToServer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .HeaderMessage header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // optional .EquipmentStatus eqpStatus = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::eqpstatus(this), target, stream);
  }

  // optional .GatewayStatus gwStatus = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::gwstatus(this), target, stream);
  }

  // optional .NotificationValues notificationval = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::notificationval(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NotificationToServer)
  return target;
}

size_t NotificationToServer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NotificationToServer)
  size_t total_size = 0;

  // required .HeaderMessage header = 1;
  if (_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .EquipmentStatus eqpStatus = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *eqpstatus_);
    }

    // optional .GatewayStatus gwStatus = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gwstatus_);
    }

    // optional .NotificationValues notificationval = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *notificationval_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NotificationToServer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NotificationToServer)
  GOOGLE_DCHECK_NE(&from, this);
  const NotificationToServer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NotificationToServer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NotificationToServer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NotificationToServer)
    MergeFrom(*source);
  }
}

void NotificationToServer::MergeFrom(const NotificationToServer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NotificationToServer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::HeaderMessage::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_eqpstatus()->::EquipmentStatus::MergeFrom(from._internal_eqpstatus());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_gwstatus()->::GatewayStatus::MergeFrom(from._internal_gwstatus());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_notificationval()->::NotificationValues::MergeFrom(from._internal_notificationval());
    }
  }
}

void NotificationToServer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NotificationToServer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotificationToServer::CopyFrom(const NotificationToServer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NotificationToServer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotificationToServer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (_internal_has_header()) {
    if (!header_->IsInitialized()) return false;
  }
  return true;
}

void NotificationToServer::InternalSwap(NotificationToServer* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(header_, other->header_);
  swap(eqpstatus_, other->eqpstatus_);
  swap(gwstatus_, other->gwstatus_);
  swap(notificationval_, other->notificationval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NotificationToServer::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::GatewayStatus* Arena::CreateMaybeMessage< ::GatewayStatus >(Arena* arena) {
  return Arena::CreateInternal< ::GatewayStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::EquipmentStatus* Arena::CreateMaybeMessage< ::EquipmentStatus >(Arena* arena) {
  return Arena::CreateInternal< ::EquipmentStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::UploadToGateway* Arena::CreateMaybeMessage< ::UploadToGateway >(Arena* arena) {
  return Arena::CreateInternal< ::UploadToGateway >(arena);
}
template<> PROTOBUF_NOINLINE ::CheckGateway* Arena::CreateMaybeMessage< ::CheckGateway >(Arena* arena) {
  return Arena::CreateInternal< ::CheckGateway >(arena);
}
template<> PROTOBUF_NOINLINE ::UploadToServer* Arena::CreateMaybeMessage< ::UploadToServer >(Arena* arena) {
  return Arena::CreateInternal< ::UploadToServer >(arena);
}
template<> PROTOBUF_NOINLINE ::NotificationValues* Arena::CreateMaybeMessage< ::NotificationValues >(Arena* arena) {
  return Arena::CreateInternal< ::NotificationValues >(arena);
}
template<> PROTOBUF_NOINLINE ::NotificationToServer* Arena::CreateMaybeMessage< ::NotificationToServer >(Arena* arena) {
  return Arena::CreateInternal< ::NotificationToServer >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
